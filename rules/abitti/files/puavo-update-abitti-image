#!/bin/sh

set -eu

# obtain an exclusive lock on myself...
# there should be only one instance of this program running
exec 3<$0
flock -nx 3 || { echo did not get a lock, exiting; exit 1; }

if ! mountpoint -q /images; then
  echo '/images is not its own partition, refusing to download abitti' >&2
  exit 1
fi

logmsg() {
  logger -s -t puavo-update-abitti-image "$@" || true
}

errmsg='unknown error'
error() {
  errmsg=$1
  logmsg -p user.err "$1"
}

edit_extra_system_contents() {
  esc_json_path='/var/lib/puavo-desktop/extra_system_contents.json'
  tmpfile="${esc_json_path}.tmp"
  if [ -e "$esc_json_path" ]; then
    jq "$@" "$esc_json_path" > "$tmpfile" || return 1
  else
    jq --null-input "$@" > "$tmpfile" || return 1
  fi
  mv "$tmpfile" "$esc_json_path"
}

post_update_actions() {
  short_abitti_version=$1
  persistent_fs=$2
  persistent_fs_for_this_version=$3

  edit_extra_system_contents --arg abitti_version "$short_abitti_version" \
    '.Abitti = $abitti_version'

  if [ ! "$persistent_fs" -ef "$persistent_fs_for_this_version" ]; then
    ln -f "$persistent_fs_for_this_version" "${persistent_fs}.tmp"
    mv "${persistent_fs}.tmp" "$persistent_fs"
  fi
}

send_status_message() {
  method=$1; shift

  dbus-send --dest=org.puavo.client.Daemon              \
            --reply-timeout=100                         \
            --print-reply=literal                       \
            --system                                    \
            /contentupdates                             \
            "org.puavo.client.contentupdates.${method}" \
            "string:Abitti"                             \
            "string:${short_abitti_version}"            \
            "$@" \
    || true
}

update_status='not_started'
send_final_status() {
  case "$update_status" in
    not_started)
      exit 0
      ;;
    started)
      send_status_message SetUpdateFailed "string:$errmsg"
      exit 1
      ;;
    success)
      send_status_message SetUpdateCompleted
      exit 0
      ;;
  esac
  update_status='final_message_sent'
}

update_progress() {
  phase=$1

  while read progress; do
    # rsync goes only from 0 --> 90 %.
    if [ "$phase" = 'rsync' ]; then
      progress=$(echo "$progress" | tr -d '\r')
      progress=$(( 90 * $progress / 100 ))
    fi
    send_status_message SetUpdateProgress "int32:${progress}"
  done
}

# be_very nice
ionice -c 3  -p $$
renice -n 20 -p $$ > /dev/null

abitti_images_dir=/images/abitti
abitti_state_dir=/state/abitti
image_server='images.opinsys.fi'

# XXX cleanup old cruft (storing these under /state/abitti now...
# XXX these lines may be removed sometimes later)
rm -f "${abitti_images_dir}/abitti.json" \
      "${abitti_images_dir}/persistent_abitti_fs"

abitti_mode=$(puavo-conf puavo.abitti.mode)
case "$abitti_mode" in
  do-nothing)
    exit 0
    ;;
  install-and-update)
    # just continue...
    ;;
  purge)
    rm -rf "$abitti_images_dir" "$abitti_state_dir"
    exit 0
    ;;
  *)
    error "unsupported abitti mode: '${abitti_mode}'"
    exit 1
    ;;
esac

abitti_version=$(puavo-conf puavo.abitti.version)
if [ -z "$abitti_version" ]; then
  error 'puavo.abitti.version is not set, doing nothing!'
  exit 1
fi

rsyncopts=''
if [ "${1:-}" = '--use-rate-limit' ]; then
  download_rate_limit=$(puavo-conf puavo.image.download.ratelimit)
  if [ -n "$download_rate_limit" ]; then
    if ! printf "%s\n" "$download_rate_limit" | grep -Eqx '[0-9]+[km]'; then
      error "the rate limit was not understood, got '$download_rate_limit'"
      exit 1
    fi
    rsyncopts="--bwlimit=${download_rate_limit}"
  fi
fi

mkdir -p "$abitti_images_dir" "$abitti_state_dir"

abitti_json_path="${abitti_state_dir}/abitti.json"
wget -q --ca-certificate=/etc/puavo/certs/rootca.pem \
     -O "${abitti_json_path}.tmp" \
     "https://${image_server}/abitti-images/abitti.json"
mv "${abitti_json_path}.tmp" "$abitti_json_path"

if [ "$abitti_version" = 'latest' ]; then
  abitti_version=$(jq -r .latest "$abitti_json_path")

  if [ -z "$abitti_version" ]; then
    error 'could not determine the latest version from abitti metadata'
    exit 1
  fi
fi

short_abitti_version=${abitti_version#abitti-v}

abitti_image="${abitti_version}.squashfs"
abitti_image_fp="${abitti_images_dir}/${abitti_image}"

# remove temporary files (of non-matching versions).
find "$abitti_images_dir" -maxdepth 1 -name '*.squashfs.tmp' \
  -a ! -name "${abitti_version}.squashfs.tmp" \
  -exec rm -f \{} \;

old_abitti_image_fp=''

# remove old squashfs files, except one that we can also use as a base
for squashfs_file in ${abitti_images_dir}/*.squashfs; do
  test -e "$squashfs_file" || continue

  if [ -n "$old_abitti_image_fp" ]; then
    rm -f "$squashfs_file"
    continue
  fi

  old_abitti_image_fp="$squashfs_file"
done

# setup persistent storage filesystem for DigabiOS/Abitti
persistent_fs="${abitti_state_dir}/persistent_abitti_fs"
persistent_fs_for_this_version="${persistent_fs}.${short_abitti_version}"
if [ ! -e "$persistent_fs_for_this_version" ]; then
  # count=14336 (7M) is the DigabiOS default, but we put a bit bigger
  # one in case it should ever grow (four times as much).
  {
    dd if=/dev/zero "of=${persistent_fs_for_this_version}.tmp" bs=512 \
       count=57344 2>/dev/null \
      && mkfs.ext4 -q -L DAT452CBDF0OGISG \
                   "${persistent_fs_for_this_version}.tmp" \
      && mv "${persistent_fs_for_this_version}.tmp" \
            "$persistent_fs_for_this_version"
  } || {
    error 'could not create a persistent filesystem for Abitti'
    exit 1
  }

  logmsg -p user.info 'created a new persistent filesystem for Abitti'
fi

# cleanup old persistent filesystems if they have not been used in 365 days
find "$abitti_state_dir" -type f -name 'persistent_abitti_fs.*' \
     -and '!' '(' -name 'persistent_abitti_fs' \
                  -or -name "persistent_abitti_fs.${short_abitti_version}" ')' \
     -and -mtime +365 -exec rm -f \{} \;

if [ -e "$abitti_image_fp" ]; then
  logmsg -p user.info "the requested abitti-image ${abitti_version} is in place"
  post_update_actions "$short_abitti_version"           \
                      "$persistent_fs"                  \
                      "$persistent_fs_for_this_version"
  exit 0
fi

# now we are going to update
update_status='started'

# update_status and short_abitti_version must be set before this:
trap send_final_status 0 INT TERM

send_status_message SetUpdateStarted

required_diskspace=$(jq -r --arg abitti_version "$abitti_version" \
                         '.images[$abitti_version].size' "$abitti_json_path")
if [ -z "$required_diskspace" ]; then
  error "image size for '$abitti_version' is not known"
  exit 1
fi
available_diskspace=$(stat -f -c '%S * %a' "$abitti_images_dir" \
                        | bc -l | xargs printf %.0f)
if [ "$available_diskspace" -lt "$required_diskspace" ]; then
  msg="only $available_diskspace bytes available on $abitti_images_dir,"
  msg="$msg need $required_diskspace bytes"
  error "$msg"
  exit 1
fi

expected_image_sha256=$(jq -r --arg abitti_version "$abitti_version" \
                 '.images[$abitti_version].sha256' "$abitti_json_path")
if [ -z "$expected_image_sha256" ]; then
  error "checksum missing for image $abitti_version"
  exit 1
fi

logmsg -p user.info "downloading $abitti_version with rsync from $image_server"

echo 0 | update_progress starting

# progress trick from /usr/sbin/puavo-install-and-update-ltspimages
rsync_error_code=$(
  {
    {
      rsync --fuzzy --inplace --progress -v $rsyncopts              \
            "${image_server}::images/abitti-images/${abitti_image}" \
            "${abitti_image_fp}.tmp" 2>/dev/null                    \
        || echo $? >&2
    } | unbuffer -p awk '
          BEGIN { progress = -1 }

          {
            if (match($2, /^([[:digit:]]+)%$/, a)) {
              new_progress = a[1]
              if (progress != new_progress) {
                progress = new_progress
                print progress
              }
            }
          }
        ' \
      | update_progress rsync
  } 2>&1 || true
)

if [ -n "$rsync_error_code" ]; then
  error "rsync failed with error code $rsync_error_code"
  exit 1
fi

echo 90 | update_progress sha256

logmsg -p user.info "checking sha256 checksum of $abitti_version"
actual_image_sha256=$(sha256sum "${abitti_image_fp}.tmp" | awk '{ print $1 }')
if [ "$actual_image_sha256" != "$expected_image_sha256" ]; then
  error "checksum mismatch for abitti-image ${abitti_version}"
  exit 1
fi

echo 99 | update_progress sha256

if [ -n "$old_abitti_image_fp" ]; then
  logmsg -p user.notice \
         "replacing old abitti-image with version ${abitti_version}"

  # Destroy the old image in the process, but always keeping one
  # *.squashfs file in place.
  mv "${abitti_image_fp}.tmp" "$old_abitti_image_fp"

  # If we fail here (in such a way that the following command never runs
  # or fails), we have the new image with the old name (and thus wrong
  # version number), but this should get fixed in a later run.
  mv "$old_abitti_image_fp" "$abitti_image_fp"
else
  mv "${abitti_image_fp}.tmp" "$abitti_image_fp"
fi

logmsg -p user.notice "new abitti-image ${abitti_version} installed!"

post_update_actions "$short_abitti_version"           \
                    "$persistent_fs"                  \
                    "$persistent_fs_for_this_version"

update_status='success'
