#!/usr/bin/tclsh

# This script forwards logs to remote syslog server, and caches them
# in case the syslog server is not responding.  Written due to observed
# issues with disk caches on rsyslog and syslog-ng.  This should work,
# reliability first, performance second.  Because this is run mostly
# on laptops, with reboots and network outages, we expect a lot of
# issues that (it appears) rsyslog and syslog-ng do not always handle.

set syslog_host [lindex $argv 0]

if {$syslog_host eq ""} {
  puts stderr "usage: puavo-caching-syslog-sender syslog_server"
  exit 1
}

set puavo_domain [exec cat /etc/puavo/domain]

set remote_cache_path "/var/log/puavo/${syslog_host}.cache"

# If remote cache filesize is greater than 32 megabytes, we simply remove
# it before doing anything (yes we lose logs but this should not normally happen
# and we do not want to waste exceeding amounts of space for caching logs
# that are not ending up anywhere).
catch {
  if {[file size $remote_cache_path] > 67108864} {
    file delete $remote_cache_path
  }
}

set syslog_memcache_index -1

# read previous file cache, if any
if {[catch { set syslog_filecache [open $remote_cache_path r] }]} {
  set syslog_memcache [list]
} else {
  set syslog_memcache [split [read $syslog_filecache] "\n"]
  close $syslog_filecache
}

set syslog_filecache [open $remote_cache_path a]

proc send_to_syslog {} {
  global puavo_domain syslog_connection syslog_host syslog_memcache \
         syslog_memcache_index syslog_sending_state

  if {[
    catch {
      set syslog_connection [socket $syslog_host 514]
      fconfigure $syslog_connection -translation binary

      # ten second timeout for send events
      set syslog_sending_state ""
      after 10000 [list set syslog_sending_state timeout]
      fileevent $syslog_connection writable {
        if {[llength $syslog_memcache] <= $syslog_memcache_index} {
	  set syslog_sending_state ok
        } else {
          set line_to_send [lindex $syslog_memcache $syslog_memcache_index]
          if {$line_to_send ne ""} {
            puts $syslog_connection $line_to_send
          }
          incr syslog_memcache_index
        }
      }

      vwait syslog_sending_state
      close $syslog_connection

      if {$syslog_sending_state eq "timeout"} {
        error "timeout sending data to remote syslog"
      }
    }
  ]} {
    return false
  }

  return true
}

proc send_to_syslog_or_cache {{msg ""}} {
  global remote_cache_path syslog_filecache syslog_memcache syslog_memcache_index

  if {$msg ne ""} {
    # add new messages to cache first
    lappend syslog_memcache $msg
    puts -nonewline $syslog_filecache $msg
    flush $syslog_filecache
  }

  if {[llength $syslog_memcache] == 0} { return }

  # send stuff to syslog
  if {[send_to_syslog]} {
    # everything has been sent to syslog, truncate file cache
    close $syslog_filecache
    set syslog_filecache [open $remote_cache_path w]
    set syslog_memcache [list]
    set syslog_memcache_index 0
  }

  if {[llength $syslog_memcache] > 0} {
    # try again after 20 seconds, if there is still something to do
    after 20000 send_to_syslog_or_cache
  }
}

fconfigure stdin -blocking 0

fileevent stdin readable {
  if {[eof stdin]} { exit 0 }
  send_to_syslog_or_cache [read stdin]
}

vwait forever
