/*
Login screen host information display

Copyright (C) 2017-2018 Opinsys Oy

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

Version 0.9.1
Author: Jarmo Pietil√§inen (jarmo@opinsys.fi)
*/

const St = imports.gi.St;
const Main = imports.ui.main;
const Lang = imports.lang;
const Shell = imports.gi.Shell;
const PanelMenu = imports.ui.panelMenu;
const PopupMenu = imports.ui.popupMenu;
const Clutter = imports.gi.Clutter;

var hostType, hostName, releaseName;

// remember to catch and handle exceptions if you call this
function readTextFile(name)
{
    return Shell.get_file_contents_utf8_sync(name);
}

// the [] operator cannot be overloaded, so we have to do it the hard way
function jval(json, key, defaultValue = "<Unknown>")
{
    return (key in json && json[key] !== null) ? json[key] : defaultValue;
}

const HostInfoButton = new Lang.Class(
{
    Name: "HostInfoButton",
    Extends: PanelMenu.Button,

    _init: function()
    {
        this.parent(0.0);

        // ---------------------------------------------------------------------
        // Create the panel button

        let buttonContainer = new St.BoxLayout({ style_class: "panel-status-menu-box" });

        buttonContainer.add_child(new St.Label({
            text: hostType + " | " + releaseName + " | " + hostName,
            y_expand: true,
            y_align: Clutter.ActorAlign.CENTER
        }));

        buttonContainer.add_child(new PopupMenu.arrowIcon(St.Side.TOP));

        this.actor.add_actor(buttonContainer);

        // ---------------------------------------------------------------------
        // Construct the popup menu

        // this menu entry cannot be highlighted or interacted with as it's
        // just a container for other stuff
        this.infoTextMenuItem = new PopupMenu.PopupBaseMenuItem({
            reactive: false,
            style_class: "infoTextMenuItem"
        });

        // contains the info text blocks, stacked vertically
        this.infoContainer = new St.BoxLayout({
            vertical: true,
            style_class: "infoTextContainer"
        });

        let c = this.infoContainer;

        try {
            // This JSON file is generated by /usr/sbin/puavo-sysinfo-collector at system
            // startup. It's nearly impossible to run that script (as root!) here
            // asynchronously without losing sanity.
            // TODO: This actually needs to be asynchronously. The current collector
            // slows down some systems too much.
            const json = JSON.parse(readTextFile("/run/puavo/puavo-sysinfo.json"));

            this.category(c, "Release");
            this.titleValue(c, "Image", jval(json, "this_image"));
            this.titleValue(c, "Name", jval(json, "this_release"));

            this.spacer(c);
            this.category(c, "Machine");
            this.titleValue(c, "BIOS",
                jval(json, "bios_vendor") + ", " +
                jval(json, "bios_version") + ", " +
                jval(json, "bios_release_date"));

            var hdText = jval(json, "blockdevice_sda_model");

            hdText += ", ";
            hdText += (parseFloat(jval(json, "blockdevice_sda_size", 0)) /
                        (1024.0 * 1024.0 * 1024.0)).toFixed(0);
            hdText += " GiB";

            if (jval(json, "ssd") == "1")
                hdText += " [SSD]";

            this.titleValue(c, "Hard drive", hdText);

            this.titleValue(c, "Processor",
                jval(json, "processorcount") + " CPU(s), " +
                jval(json, "processor0"));
            this.titleValue(c, "Memory",
                (parseFloat(jval(json, "memorysize_mb", 0.0)) / 1024.0).toFixed(2) + " GiB");

            const memory = jval(json, "memory");

            if (memory && memory.length > 0) {
                for (var i = 0; i < memory.length; i++) {
                    const size = memory[i].size;

                    // the texts here are indented using spaces, but we *really* should create
                    // a new St.BoxLayout() element to indent them... maybe one day...

                    if (size == 0) {
                        this.titleValue(c, "    Slot #" + i, "<empty>");
                        continue;
                    }

                    var text = "";

                    text += "Size: " + size + "MiB; ";
                    text += "Slot: " + memory[i].slot + "; ";
                    text += "Product: " + memory[i].product + "; ";
                    text += "Vendor: " + memory[i].vendor;

                    this.titleValue(c, "    Slot #" + i, text);
                }
            }

            this.spacer(c);
            this.category(c, "Network");
            this.titleValue(c, "MAC address", jval(json, "macaddress"));
            this.titleValue(c, "WiFi", jval(json, "wifi"));

            this.spacer(c);
            this.category(c, "Serial numbers");
            this.titleValue(c, "Machine", jval(json, "serialnumber"));
            this.titleValue(c, "Mainboard", jval(json, "boardserialnumber"));

            if ("lspci_values" in json && json["lspci_values"].length > 0) {
                this.spacer(c);
                this.category(c, "Some lspci values");

                // get around JS's variable scoping weirdness
                let self = this;

                json["lspci_values"].forEach(function(e) {
                    self.value(self.infoContainer, e);
                });
            } else {
                // this can happen, at least in theory...
                this.spacer(c);
                this.category(c, "No lspci output listed in the JSON");
            }
        } catch (e) {
            // show the error
            let r = new St.BoxLayout();

            this.addLabel(r, {
                text: "Cannot display system information. This is a serious " +
                      "error, please report it.\n" + e.message,
                style_class: "infoErrorTitle"
            });

            c.add_actor(r);
        }

        // finally add the fake menu item to the menu
        this.infoTextMenuItem.actor.add(this.infoContainer);
        this.menu.addMenuItem(this.infoTextMenuItem);
    },

    // -------------------------------------------------------------------------
    // -------------------------------------------------------------------------

    // Adds a text label in the container. "params" must contain the text value,
    // style class and possibly other, optional, arguments.
    addLabel: function(container, params)
    {
        container.add_actor(new St.Label(params));
    },

    // adds a category title
    category: function(where, value)
    {
        let r = new St.BoxLayout();

        this.addLabel(r, { text: value, style_class: "infoTextCategory" });
        where.add_actor(r);
    },

    // adds an empty spacer row (this used to be a CSS property,
    // but it was hard to control)
    spacer: function(where)
    {
        this.category(where, " ");
    },

    // add a value without title
    value: function(where, value)
    {
        let r = new St.BoxLayout();

        this.addLabel(r, { text: value, style_class: "infoTextPlainValue" });
        where.add_actor(r);
    },

    // add a title with value and an optional "warning" text displayed
    // at the end
    titleValue: function(where, title, value, warningText = null)
    {
        let r = new St.BoxLayout();

        this.addLabel(r, { text: title + ":", style_class: "infoTextKey" });
        this.addLabel(r, { text: value, style_class: "infoTextValue" });

        if (warningText)
            this.addLabel(r, { text: " [" + warningText + "]", style_class: "infoTextWarning" });

        where.add_actor(r);
    },
});

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

function init()
{
    // these are displayed on the button, so they must be read before doing
    // anything else
    try {
        hostType = readTextFile("/etc/puavo/hosttype").trim();
    } catch (e) {
        hostType = "<Error>";
    }

    try {
        hostName = readTextFile("/etc/puavo/hostname").trim();
    } catch (e) {
        hostName = "<Error>";
    }

    try {
        releaseName = readTextFile("/etc/puavo-image/release").trim();
    } catch (e) {
        releaseName = "<Error>";
    }
}

let hostInfoMenuButton = null;

function enable()
{
    hostInfoMenuButton = new HostInfoButton();

    // the last argument indicates which panel box to use: left, center, right
    Main.panel.addToStatusArea("hostInfoButton", hostInfoMenuButton, 0, "left");
}

function disable()
{
    hostInfoMenuButton.destroy();
    hostInfoMenuButton = null;
}
