#!/bin/bash

set -eu

colorize() {
  local yellow_limit grey_limit green_limit value text
  yellow_limit=$1
  grey_limit=$2
  green_limit=$3
  value=$4
  text=$5

  if [ "$value" -ge "$green_limit" ]; then
    echo -e "\e[1;32m${text}\e[0m" # green
  elif [ "$value" -ge "$grey_limit" ]; then
    echo "$text"                   # grey
  elif [ "$value" -ge "$yellow_limit" ]; then
    echo -e "\e[1;33m${text}\e[0m" # yellow
  else
    echo -e "\e[1;31m${text}\e[0m" # red
  fi
}

list_disks() {
  local colorized_disk_info disk disk_label disk_devices disk_size_in_gb
  disk_devices=$(facter --json disks | jq -r '.disks | keys | .[]' \
                   | grep -E '^(mmcblk|nvme|sd|vd)')
  for disk in $disk_devices; do
    disk_label="$(facter "disks.${disk}.model") / $(facter disks.${disk}.size)"
    colorized_disk_info=$(colorize 128000000000 256000000000 512000000000 \
                                   "$(facter disks.${disk}.size_bytes)"   \
                                   "$disk_label")

    printf "disk %-12s%s\n" "${disk}:" "$colorized_disk_info"
  done
}

list_networks() {
  local netdev network_devices
  network_devices=$(facter --json networking.interfaces \
                      | jq -r '.["networking.interfaces"] | keys | .[]' \
                      | grep -v lo | sort)
  for netdev in $network_devices; do
    printf "network %-9sIP %s / MAC %s\n" "${netdev}:"    \
           "$(facter networking.interfaces.${netdev}.ip)" \
           "$(facter networking.interfaces.${netdev}.mac)"
  done
}

windows_license() {
  local machine_build_id windows_product_key

  windows_product_key=$(
    strings /sys/firmware/acpi/tables/MSDM 2>/dev/null \
      | awk '$1 ~ /^[0-9A-Z]{5}-[0-9A-Z]{5}-[0-9A-Z]{5}-[0-9A-Z]{5}-[0-9A-Z]{5}$/')
  [ -z "$windows_product_key" ] && return 0
  machine_build_id=$(strings /sys/firmware/dmi/tables/DMI 2>/dev/null \
                       | grep '^BUILDID')
  if [ -n "$machine_build_id" ]; then
    machine_build_id=" (${machine_build_id})"
  fi

  printf %s "${windows_product_key}${machine_build_id}"
}

get_cpu_value() {
  # XXX This is a very crude way of evaluating processor "goodness".
  # XXX For example it does not consider AMD CPUs at all.
  case "$1" in
    *i3-*) echo 1 ;;
    *i5-*) echo 2 ;;
    *i7-*) echo 3 ;;
    *)     echo 0 ;;
  esac
}

darkdm_systeminfo()
{
  this_image=$(cat /etc/puavo-image/name)
  this_release=$(cat /etc/puavo-image/release)

  colorized_memory=$(colorize 4183116800 8366233600 16732467200     \
                              "$(facter memory.system.total_bytes)" \
                              "$(facter memory.system.total)")
  cpu=$(facter processors.models.1)
  cpu_text="$(facter processors.count) CPUs / ${cpu}"
  colorized_cpu=$(colorize 1 2 3 "$(get_cpu_value "$cpu")" "$cpu_text")

  cat <<EOF
image:   ${this_image}
release: ${this_release}

bios:            $(facter dmi.bios.vendor) / $(facter dmi.bios.version)
cpu:             ${colorized_cpu}
$(list_disks)
memory:          ${colorized_memory}
$(list_networks)
product:         $(facter dmi.manufacturer) / $(facter dmi.product.name)
serial numbers:  $(facter dmi.product.serial_number) (machine) / $(facter dmi.board.serial_number) (board)
Windows license: $(windows_license)
some pci devices:
$(lspci | awk '$2 == "Network" || $2 == "VGA"' | sed 's/^/  /')
EOF
}

darkdm_reboot()
{
  local i

  for i in $(seq 5 -1 1); do
    echo -n -e "\rRebooting in ${i}s. (Press Ctrl-C to cancel)"
    sleep 1 || return 1
  done
  echo -e "\rRebooting now!                              "

  reboot
}

darkdm_install()
{
  if ! /usr/sbin/puavo-install "$@"; then
    # give some time for users to read the error message, if there is any
    echo
    sleep 2
    return 1
  fi

  darkdm_reboot
}

darkdm_print_help()
{
  cat <<'EOF'

Puavo OS Command Shell

Commands:
  build                - build Puavo OS image and poweroff
  expert-install       - install Puavo OS with more detailed questions
  expert-preinstall    - install without registering, expert mode
  install              - install Puavo OS to this device and reboot
  kbd [layout]         - set keyboard layout
  live                 - switch to graphical mode
  make-install-disk    - make a bootable usb flash drive or some such
  nmtui                - configure network (not available on netboot devices)
  poweroff             - poweroff the system in 5 seconds
  preinstall           - install without registering
  preseed-install (pi) - install with a preseed
  preseed-preinstall   - install without registering but with a preseed
  reboot               - reboot the system in 5 seconds
  restoredisk          - restore from bootserver (only on netboot devices)
  savedisk             - save to bootserver (only on netboot devices)
  shell                - spawn a shell
  update               - update the local Puavo OS installation and reboot
EOF
}

darkdm_shell()
{
  /bin/bash
}

darkdm_update()
{
  local image_name update_status

  update_status=0

  if image_name=$(cat /etc/puavo-image/name 2>/dev/null); then
    /usr/sbin/puavo-install-and-update-ltspimages \
      --install-from-nbd /dev/nbd0 "$image_name" || update_status=1
  else
    update_status=1
  fi

  if ! /usr/lib/puavo-ltsp-install/update-configuration >/dev/null 2>&1; then
    echo 'Configuration update FAILED!' >&2
    update_status=1
  else
    echo 'Configuration update OK.'
  fi

  if [ "$update_status" -ne 0 ]; then
    return "$update_status"
  fi

  darkdm_reboot
}

darkdm_poweroff()
{
  local i

  for i in $(seq 5 -1 1); do
    echo -n -e "\rPowering-off in ${i}s. (Press Ctrl-C to cancel)"
    sleep 1 || return 1
  done
  echo -e "\rPowering-off now!                              "

  poweroff
}

darkdm_build()
{
  /usr/lib/puavo-ltsp-client/handle-image-build-request || return 1

  darkdm_poweroff
}

darkdm_kbd() {
  new_layout=$1

  current_layout=$(localectl status \
                     | awk '/X11 Layout:/ { split($3, a, ","); print a[1] }')

  if [ -z "$new_layout" ]; then
    possible_layouts="$(localectl list-x11-keymap-layouts | xargs \
                          | fmt -w 70 | sed 's/^/  /')"

    cat <<EOF
Current keyboard layout is: $current_layout
Choose from layouts:
$possible_layouts
EOF
    read -p 'Choose keyboard layout: ' new_layout
  fi

  if [ -z "$new_layout" ]; then
    echo 'Not changing keyboard layout'
  elif localectl set-keymap "$new_layout"; then
    echo "Changed keyboard layout to \"${new_layout}\""
  else
    echo "Could not change keyboard layout" >&2
  fi

  setupcon

  sleep 0.5
  echo
}

darkdm_live() {
  echo -n 'switching to graphical mode'
  # needed due to some bug in Buster:
  service accounts-daemon start || true
  echo -n .; sleep 1
  echo -n .; sleep 1
  echo -n .; sleep 1

  # switch to GUI mode (should stop puavo-darkdm as a side effect)
  systemctl isolate graphical.target
}

darkdm_menu()
{
  local command forced initial_command prompt

  initial_command=$1
  forced=$2

  while true; do
    echo "$systeminfo"
    darkdm_print_help || return 1

    if [ -n "$initial_command" ]; then
      prompt="[${initial_command}]> "
    else
      prompt='> '
    fi

    if [ "$forced" = '--force' ]; then
      command="$initial_command"
    else
      read -e -p "$prompt" command command_args || return 1
      if [ -z "$command" -a -n "$initial_command" ]; then
        command="$initial_command"
      fi
    fi

    case "$command" in
      build)
        darkdm_build || return 1
        ;;
      expert-install)
        darkdm_install expert-install || return 1
        ;;
      expert-preinstall)
        darkdm_install expert-preinstall || return 1
        ;;
      install)
        darkdm_install || return 1
        ;;
      kbd)
        darkdm_kbd "$command_args" || return 1
        ;;
      live)
        darkdm_live || return 1
        ;;
      make-install-disk)
        puavo-make-install-disk || return 1
        ;;
      nmtui)
        if [ ! -x /usr/bin/nmtui ]; then
          echo 'nmtui not available' >&2
          return 1
        else
          nmtui || return 1
        fi
        ;;
      poweroff)
        darkdm_poweroff || return 1
        ;;
      preinstall)
        darkdm_install preinstall || return 1
        ;;
      preseed-preinstall)
        darkdm_install preseed-preinstall || return 1
        ;;
      preseed-install|pi)
        darkdm_install preseed-install || return 1
        ;;
      reboot)
        darkdm_reboot || return 1
        ;;
      restoredisk)
        puavo-disk-clone restoredisk || return 1
        ;;
      savedisk)
        puavo-disk-clone savedisk || return 1
        ;;
      shell)
        darkdm_shell || return 1
        ;;
      update)
        darkdm_update || return 1
        ;;
      *)
        echo "Error: Invalid command '${command}'." >&2
        ;;
    esac
  done
}

check_forced_operation() {
  local forced_operation image_server preseed_json

  if ! image_server=$(/usr/lib/puavo-ltsp-client/lookup-image-server-by-dns); then
    return 1
  fi

  preseed_url="https://${image_server}/preseeds/index.json"
  if ! preseed_json=$(curl --cacert /etc/puavo-conf/rootca.pem --fail \
                        --show-error --silent "$preseed_url"); then
    return 1
  fi

  forced_operation=$(printf %s "$preseed_json" | jq -r '.["force-operation"]')
  if [ "$forced_operation" = 'null' ]; then forced_operation=''; fi
  if [ "$forced_operation" = '' ]; then return 1; fi

  printf "%s" "$forced_operation"
}

darkdm_main()
{
  local forced
  local hosttype
  local initial_command

  hosttype=$(cat /etc/puavo/hosttype)
  case "$hosttype" in
    laptop|wirelessaccesspoint)
      initial_command='update'
      ;;
    unregistered)
      initial_command='install'
      ;;
    *)
      initial_command=
      ;;
  esac

  forced=''
  if forced_operation=$(check_forced_operation 2>/dev/null); then
    initial_command="$forced_operation"
    forced='--force'
  fi

  darkdm_menu "$initial_command" "$forced" || return 1
}


echo 'Gathering system information...'
echo
systeminfo=$(darkdm_systeminfo 2>/dev/null || true)

while true; do
  if darkdm_main; then
    echo 'Operation was a success.'
  else
    echo 'Operation failed.'
  fi

  echo 'Press ENTER to continue.'
  read _
done
