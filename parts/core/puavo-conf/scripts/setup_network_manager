#!/usr/bin/ruby

#
# Generate and update NetworkManager configuration files
# based on network information in Puavo.
#
# Reads json from /etc/puavo/wlan.json
# and excepts it to contain something like this
# (only "type", "ssid" and possibly "password"/"identity"/"certs" are used,
# "wlan_ap" is not used by this script).
# The "type" can be "open", "psk" or "eap-tls".
#
# [
#   {
#     "type":     "psk",
#     "ssid":     "Ankkalinna",
#     "wlan_ap":  true,
#     "password": "AkuAnkka"
#   },
#   {
#     "type":     "open",
#     "ssid":     "Humppaajat",
#     "wlan_ap":  null,
#     "password": ""
#   },
#   {
#     "type":     "eap-tls",
#     "ssid":     "Baggins",
#     "wlan_ap":  null,
#     "identity": "Shire",
#     "certs": {
#       "ca_cert":             "...",
#       "client_cert":         "...",
#       "client_key":          "...",
#       "client_key_password": "mysecretclientkeypassword"
#     }
#   }
# ]
#

require 'puavo/conf'

puavoconf = Puavo::Conf.new
exit(0) unless puavoconf.get('puavo.service.NetworkManager.enabled') == 'true'

puavoconf.close

require 'base64'
require 'fileutils'
require 'json'
require 'uuidtools'

Nm_config_directory = '/state/etc/NetworkManager/system-connections'

class Wlan
  def initialize(ssid)
    raise "Wlan ssid is not set" if (ssid.nil? || ssid.empty?)

    @id   = "puavo-#{ ssid.scan(/[[:alnum:]_-]/).join }"
    @ssid = ssid

    # try to read uuid from the old config file, or generate with uuidgen
    @uuid = read_uuid_from_config || uuidgen
  end

  def nm_config_path
    "#{ Nm_config_directory }/#{ @id }"
  end

  def read_uuid_from_config
    begin
      section = ''
      IO.readlines(nm_config_path).each do |line|
        section_match = line.match(/^\[(.*)\]$/)
        if section_match then
          section = section_match[1]
          next
        end

        uuid_match = line.match(/^uuid=(.*)$/)
        if section == 'connection' and uuid_match
          return uuid_match[1]
        end
      end
    rescue
      nil       # return nil in case we there was an error
                # (could be limited to Errno::ENOENT perhaps?)
    end

    nil         # return nil in case there was file but we could not find
                # uuid in it
  end

  def update_file
    tmpfile_path = "#{ nm_config_path }.tmp"
    File.open(tmpfile_path, 'w', 0600) { |f| f.print config }

    if (FileUtils.compare_file(nm_config_path, tmpfile_path) rescue false) then
      File.delete(tmpfile_path)
    else
      File.rename(tmpfile_path, nm_config_path)
    end
  end

  def uuidgen
    UUIDTools::UUID.random_create.to_s
  end
end

class Wlan::EapTls < Wlan
  # This path must be linked under /state on laptops, that is why it is
  # under /etc/NetworkManager/system-connections.
  Network_manager_certs_dir = '/etc/NetworkManager/system-connections/.certs'

  def certdir
    "#{ Network_manager_certs_dir }/#{ @ssid }"
  end

  def ca_cert_path;     "#{ certdir }/ca_cert";     end
  def client_cert_path; "#{ certdir }/client_cert"; end
  def client_key_path;  "#{ certdir }/client_key";  end

  def initialize(ssid, identity, certs)
    raise 'Wlan eap-tls ssid is not a non-empty string' \
      unless ssid.kind_of?(String) && !ssid.empty?
    raise 'Wlan eap-tls identity is not a non-empty string' \
      unless identity.kind_of?(String) && !identity.empty?
    raise 'Wlan eap-tls certs is not a hash' unless certs.kind_of?(Hash)
    raise 'Wlan eap-tls certs/ca_cert is not a string' \
      unless certs['ca_cert'].kind_of?(String) && !certs['ca_cert'].empty?
    raise 'Wlan eap-tls certs/client_cert is not a non-empty string' \
      unless certs['client_cert'].kind_of?(String) \
               && !certs['client_cert'].empty?
    raise 'Wlan eap-tls certs/client_key is not a non-empty string' \
      unless certs['client_key'].kind_of?(String) \
               && !certs['client_key'].empty?
    raise 'Wlan eap-tls certs/client_key_password is not a string' \
      unless certs['client_key_password'].kind_of?(String)

    @ca_cert             = Base64.decode(certs['ca_cert'])
    @client_cert         = Base64.decode(certs['client_cert'])
    @client_key          = Base64.decode(certs['client_key'])
    @client_key_password = certs['client_key_password']
    @identity            = identity

    super(ssid)
  end

  def config
    <<"EOF"
[connection]
id=#{ @id }
uuid=#{ @uuid }
type=wifi
permissions=

[wifi]
mode=infrastructure
ssid=#{ @ssid }

[wifi-security]
key-mgmt=wpa-eap

[802-1x]
ca-cert=#{ ca_cert_path }
client-cert=#{ client_cert_path }
eap=tls;
identity=#{ @identity }
private-key=#{ client_key_path }
private-key-password=#{ @client_key_password }

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
  end

  def update_file
    begin
      Dir.mkdir(Network_manager_certs_dir)
    rescue Errno::EEXIST
    end
    begin
      Dir.mkdir(certdir)
    rescue Errno::EEXIST
    end

    cert_file_paths = {
      ca_cert_path()     => @ca_cert,
      client_cert_path() => @client_cert,
      client_key_path()  => @client_key,
    }

    cert_file_paths.each do |path, data|
      tmppath = "#{ path }.tmp"
      File.open(tmppath, 'w') { |f| f.write(data) }
      File.rename(tmppath, path)
    end

    super
  end
end

class Wlan::Open < Wlan
  def config
    <<"EOF"
[connection]
id=#{ @id }
uuid=#{ @uuid }
type=wifi
permissions=

[wifi]
mode=infrastructure
ssid=#{ @ssid }

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
  end
end

class Wlan::Psk < Wlan
  def initialize(ssid, psk)
    raise "Wlan ssid is not set" if (ssid.nil? || ssid.empty?)
    raise "Wlan password is not set for ssid=#{ ssid }" \
      if (psk.nil? || psk.empty?)
    @psk = psk

    super(ssid)
  end

  def config
    <<"EOF"
[connection]
id=#{ @id }
uuid=#{ @uuid }
type=wifi
permissions=

[wifi]
mode=infrastructure
ssid=#{ @ssid }

[wifi-security]
auth-alg=open
key-mgmt=wpa-psk
psk=#{ @psk }

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
  end
end

config_path = '/etc/puavo/wlan.json'

begin
  networks = JSON.parse(IO.read(config_path))
rescue StandardError => e
  warn "Could not read and interpret #{ config_path }: #{ e.message }."
  exit(1)
end

status = 0

networks.each do |network|
  begin
    wlan \
      = case network['type']
          when 'eap-tls'
            Wlan::EapTls.new(network['ssid'],
                             network['identity'],
                             network['certs'])
          when 'open'
            Wlan::Open.new(network['ssid'])
          when 'psk'
            Wlan::Psk.new(network['ssid'], network['password'])
          else
            warn "Unsupported wlan type #{ network['type'] }"
        end

    if wlan
      wlan.update_file
    end
  rescue StandardError => e
    warn "Problem applying network settings: #{ e.message }"
    status = 1
  end
end

exit(status)
