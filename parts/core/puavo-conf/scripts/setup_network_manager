#!/usr/bin/ruby

#
# Generate and update NetworkManager configuration files
# based on network information in Puavo.
#
# Reads json from /etc/puavo/wlan.json
# and excepts it to contain something like this
# (only "type", "ssid" and possibly
#  "password"/"identity"/"certs"/"phase2-autheap" are used,
# "wlan_ap" is not used by this script).
# The "type" can be "open", "psk", "eap-tls" or "eap-ttls".
#
# EXAMPLES:
#
# [
#   {
#     "type":     "psk",
#     "ssid":     "Ankkalinna",
#     "wlan_ap":  true,
#     "password": "AkuAnkka"
#   },
#   {
#     "type":     "open",
#     "ssid":     "Humppaajat",
#     "wlan_ap":  null,
#     "password": ""
#   },
#   {
#     "type":     "eap-tls",
#     "ssid":     "Baggins",
#     "wlan_ap":  null,
#     "identity": "Shire",
#     "certs": {
#       "ca_cert":             "...",
#       "client_cert":         "...",
#       "client_key":          "...",
#       "client_key_password": "mysecretclientkeypassword"
#     }
#   },
#   {
#     "type":     "eap-ttls",
#     "ssid":     "Hogwarts
#     "wlan_ap":  null,
#     "identity": "Dumbledore",
#     "password": "H0rcrux"
#   }
# ]
#

require 'puavo/conf'

puavoconf = Puavo::Conf.new
exit(0) unless puavoconf.get('puavo.service.NetworkManager.enabled') == 'true'

require 'json'

status = 0

begin
  no_autoconnect_networks \
    = JSON.parse( puavoconf.get('puavo.wireless.nm.no_autoconnect_networks') )
rescue StandardError => e
  warn 'Problem parsing puavo.wireless.nm.no_autoconnect_networks:' \
         + " #{ e.message }"
  no_autoconnect_networks = []
  status = 1
end

puavoconf.close

require 'base64'
require 'fileutils'
require 'json'
require 'uuidtools'

Nm_config_directory = '/state/etc/NetworkManager/system-connections'
Puavo_wlan_label = '# automatically generated from Puavo'

class Wlan
  def initialize(ssid)
    raise "Wlan ssid is not set" if (ssid.nil? || ssid.empty?)

    @id   = "puavo-#{ ssid.scan(/[[:alnum:]_-]/).join }"
    @ssid = ssid

    # try to read uuid from the old config file, or generate with uuidgen
    @uuid = read_uuid_from_config || uuidgen
  end

  def config(config_text)
    Puavo_wlan_label + "\n" + config_text
  end

  def nm_config_path
    "#{ Nm_config_directory }/#{ @id }"
  end

  def read_uuid_from_config
    begin
      section = ''
      IO.readlines(nm_config_path).each do |line|
        section_match = line.match(/^\[(.*)\]$/)
        if section_match then
          section = section_match[1]
          next
        end

        uuid_match = line.match(/^uuid=(.*)$/)
        if section == 'connection' and uuid_match
          return uuid_match[1]
        end
      end
    rescue
      nil       # return nil in case we there was an error
                # (could be limited to Errno::ENOENT perhaps?)
    end

    nil         # return nil in case there was file but we could not find
                # uuid in it
  end

  def update_file
    tmpfile_path = "#{ nm_config_path }.tmp"
    File.open(tmpfile_path, 'w', 0600) { |f| f.print config }

    if (FileUtils.compare_file(nm_config_path, tmpfile_path) rescue false) then
      File.delete(tmpfile_path)
    else
      File.rename(tmpfile_path, nm_config_path)
    end
  end

  def uuidgen
    UUIDTools::UUID.random_create.to_s
  end
end

class Wlan::Eap < Wlan
  # This path must be linked under /state on laptops, that is why it is
  # under /etc/NetworkManager/system-connections.
  Network_manager_certs_dir = '/etc/NetworkManager/system-connections/.certs'

  def certdir
    "#{ Network_manager_certs_dir }/#{ @ssid }"
  end

  def ca_cert_path;     "#{ certdir }/ca_cert";     end
  def client_cert_path; "#{ certdir }/client_cert"; end
  def client_key_path;  "#{ certdir }/client_key";  end

  def initialize(ssid, identity, password, certs, phase2_autheap)
    raise 'Wlan eap-tls ssid is not a non-empty string' \
      unless ssid.kind_of?(String) && !ssid.empty?
    raise 'Wlan eap-tls identity is not a non-empty string' \
      unless identity.kind_of?(String) && !identity.empty?

    @identity       = identity
    @password       = password
    @phase2_autheap = phase2_autheap

    @ca_cert             = nil
    @client_cert         = nil
    @client_key          = nil
    @client_key_password = nil

    if certs.kind_of?(Hash) then
      if certs['ca_cert'].kind_of?(String) && !certs['ca_cert'].empty? then
        @ca_cert = Base64.decode64(certs['ca_cert'])
      end
      if certs['client_cert'].kind_of?(String) \
           && !certs['client_cert'].empty? then
        @client_cert = Base64.decode64(certs['client_cert'])
      end
      if certs['client_key'].kind_of?(String) \
           && !certs['client_key'].empty? then
        @client_key = Base64.decode64(certs['client_key'])
      end
      if certs['client_key_password'].kind_of?(String) \
           && !certs['client_key_password'].empty? then
        @client_key_password = certs['client_key_password']
      end
    end

    super(ssid)
  end

  def config
    super(<<"EOF")
[connection]
id=#{ @id }
uuid=#{ @uuid }
type=wifi
permissions=

[wifi]
mode=infrastructure
ssid=#{ @ssid }

[wifi-security]
auth-alg=open
key-mgmt=wpa-eap

[802-1x]
#{
  [ "eap=#{ eap_type }",
    "identity=#{ @identity }",
    @password ? "password=#{ @password }" : nil,
    @phase2_autheap ? "phase2-autheap=#{ @phase2_autheap }" : nil,
    certificates_for_network_manager,
  ].compact.join("\n")
}

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
  end

  def certificates_for_network_manager
    return nil \
      unless @ca_cert || @client_cert || @client_key || @client_key_password

    [
      @ca_cert     ? "ca-cert=#{ ca_cert_path }"         : nil,
      @client_cert ? "client-cert=#{ client_cert_path }" : nil,
      @client_key  ? "private-key=#{ client_key_path }"  : nil,
      @client_key_password \
        ? "private-key-password=#{ @client_key_password }" : nil,
    ].compact.join("\n")
  end

  def update_file
    if @ca_cert || @client_cert || @client_key then
      begin
        Dir.mkdir(Network_manager_certs_dir)
      rescue Errno::EEXIST
      end
      begin
        Dir.mkdir(certdir)
      rescue Errno::EEXIST
      end
    end

    cert_file_paths = {
      ca_cert_path()     => @ca_cert,
      client_cert_path() => @client_cert,
      client_key_path()  => @client_key,
    }

    cert_file_paths.each do |path, data|
      if data then
        tmppath = "#{ path }.tmp"
        File.open(tmppath, 'w') { |f| f.write(data) }
        File.rename(tmppath, path)
      else
        File.unlink(path)
      end
    end

    if !@ca_cert && !@client_cert && !@client_key then
      File.unlink(certdir)
    end

    super
  end
end

class Wlan::Eap::Tls < Wlan::Eap
  def eap_type; 'tls'; end
end

class Wlan::Eap::Ttls < Wlan::Eap
  def eap_type; 'ttls'; end
end

class Wlan::Open < Wlan
  def config
    super(<<"EOF")
[connection]
id=#{ @id }
uuid=#{ @uuid }
type=wifi
permissions=

[wifi]
mode=infrastructure
ssid=#{ @ssid }

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
  end
end

class Wlan::Psk < Wlan
  def initialize(ssid, psk)
    raise "Wlan ssid is not set" if (ssid.nil? || ssid.empty?)
    raise "Wlan password is not set for ssid=#{ ssid }" \
      if (psk.nil? || psk.empty?)
    @psk = psk

    super(ssid)
  end

  def config
    super(<<"EOF")
[connection]
id=#{ @id }
uuid=#{ @uuid }
type=wifi
permissions=

[wifi]
mode=infrastructure
ssid=#{ @ssid }

[wifi-security]
auth-alg=open
key-mgmt=wpa-psk
psk=#{ @psk }

[ipv4]
dns-search=
method=auto

[ipv6]
addr-gen-mode=stable-privacy
dns-search=
method=auto
EOF
  end
end

config_path = '/etc/puavo/wlan.json'

begin
  networks = JSON.parse(IO.read(config_path))
rescue StandardError => e
  warn "Could not read and interpret #{ config_path }: #{ e.message }."
  exit(1)
end

puavo_networks = []

networks.each do |network|
  puavo_networks << network['ssid']

  begin
    wlan \
      = case network['type']
          when 'eap-tls', 'eap-ttls'
            wlan_class = (network['type'] == 'eap-tls') \
                            ? Wlan::Eap::Tls : Wlan::Eap::Ttls
            wlan_class.new(network['ssid'],
                           network['identity'],
                           network['password'],
                           network['certs'],
                           network['phase2-autheap'])
          when 'open'
            Wlan::Open.new(network['ssid'])
          when 'psk'
            Wlan::Psk.new(network['ssid'], network['password'])
          else
            warn "Unsupported wlan type #{ network['type'] }"
        end

    if wlan then
      wlan.update_file
    end
  rescue StandardError => e
    warn "Problem applying network settings: #{ e.message }"
    status = 1
  end
end

# remove stale network settings
Dir.glob("#{ Nm_config_directory }/puavo-*") do |nm_conf_path|
  begin
    is_automatic = false
    ssid = ''

    File.readlines(nm_conf_path).each do |line|
      case line.chomp
        when Puavo_wlan_label
          is_automatic = true
        when /^ssid=(.*)$/
          ssid = $1
      end
    end

    # XXX Add "&& is_automatic" later to the following test so that
    # XXX user generated networks with "puavo-"-prefix can be allowed
    # XXX (currently user can not have a network with "puavo-*"-ssid).
    if !puavo_networks.include?(ssid) then
      File.unlink(nm_conf_path)
    end
  rescue StandardError => e
    warn "Problem removing stale network setting #{ nm_conf_path }:" \
           + " #{ e.message }"
    status = 1
  end
end

# Add autoconnect=false to network-connections as suggested by
# puavo.wireless.nm.no_autoconnect_networks puavo-conf variable.
Dir.glob("#{ Nm_config_directory }/*") do |nm_conf_path|
  begin
    add_autoconnect = false

    lines = File.readlines(nm_conf_path)
    lines.each do |line|
      match = line.chomp.match(/^ssid=(.*)$/)
      if match && no_autoconnect_networks.include?(match[1]) then
        add_autoconnect = true
        break
      end
    end

    next unless add_autoconnect

    autoconnect_written = false

    tmpfile = "#{ nm_conf_path }.tmp"
    File.open(tmpfile, 'w') do |f|
      lines.each do |line|
        case line
          when /^type=/
            f.write(line)
            f.write("autoconnect=false\n")
            autoconnect_written = true
          when /^autoconnect=/
            f.write(line) unless autoconnect_written
          else
            f.write(line)
        end
      end
    end

    File.rename(tmpfile, nm_conf_path)

    raise 'Could not find a place to write autoconnect=false' \
      unless autoconnect_written

  rescue StandardError => e
    warn "Could not add autoconnect=false to #{ nm_conf_path }: #{ e.message }"
    status = 1
  end
end

exit(status)
