#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import datetime
import errno
import fcntl
import filecmp
import gettext
import gi
import glob
import json
import os
import requests
import shutil
import signal
import subprocess
import sys
import threading
import time

gi.require_version('AppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AppIndicator3
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import Notify

from requests.auth import HTTPBasicAuth

gettext.bindtextdomain('puavo-ers-applet', '/usr/share/locale')
gettext.textdomain('puavo-ers-applet')
_tr = gettext.gettext

KTP_JAKO_DIR       = os.path.join(os.environ['HOME'], 'ktp-jako')
EXAMS_ARCHIVE_DIR  = os.path.join(KTP_JAKO_DIR, 'Arkisto')
EXAMS_DIR          = os.path.join(KTP_JAKO_DIR, '.exams')
EXAMS_JSON_FILE    = os.path.join(KTP_JAKO_DIR, '.exams.json')
EXAMS_UPCOMING_DIR = os.path.join(KTP_JAKO_DIR, 'Tulevat')

def rm_f(path):
  try:
    os.unlink(path)
  except OSError as e:
    if e.errno != errno.ENOENT:
      raise e


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


class PuavoErsApplet:
  NAKSU_ORIGIN_PATH = '/opt/abitti-naksu/naksu'
  PUAVO_ERS_DIR = os.path.join(os.environ['HOME'], '.puavo', 'puavo-ers')
  NAKSU_BIN_PATH = os.path.join(PUAVO_ERS_DIR, 'naksu')

  def __init__(self):
    self.indicator \
      = AppIndicator3.Indicator.new('puavo-ers-applet',
          '/usr/share/icons/Faenza/emblems/64/emblem-default.png',
          AppIndicator3.IndicatorCategory.SYSTEM_SERVICES)
    self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

    self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

    # XXX do we need this?
    Notify.init('puavo-ers-applet')

    os.makedirs(self.PUAVO_ERS_DIR, exist_ok=True)

    self.menu = Gtk.Menu()
    self.old_exams = []
    self.password_buttons = []

    self.indicator.set_menu(self.menu)

    instructions = Gtk.MenuItem(
                     _tr('click passphrase below put it into clipboard'))
    instructions.set_sensitive(False)
    self.menu.append(instructions)
    separator = Gtk.SeparatorMenuItem()
    self.menu.append(separator)

    self.menu.show_all()

    self.exam_sync = PuavoErsExamSync()
    self.exam_sync.start()

    self.exam_zipper = PuavoErsExamZipper()
    self.exam_zipper.start()

    if not os.path.exists(self.NAKSU_BIN_PATH):
      shutil.copy2(self.NAKSU_ORIGIN_PATH, self.NAKSU_BIN_PATH)


  def main(self):
    self.run_naksu()
    GObject.timeout_add_seconds(1, self.update_passwords)
    Gtk.main()


  def run_naksu(self):
    cmd = [ '/usr/bin/terminator', '-T', 'naksu terminal',
            '--working-directory=' + self.PUAVO_ERS_DIR,
            '-x', './naksu', '--self-update=enabled' ]
    (pid, stdin, stdout, stderr) = GObject.spawn_async(cmd,
      flags=GLib.SPAWN_DO_NOT_REAP_CHILD|GLib.SPAWN_STDERR_TO_DEV_NULL,
      standard_input=True, standard_output=True)

    self.naksu_pid = pid

    fl = fcntl.fcntl(stdout, fcntl.F_GETFL)
    fcntl.fcntl(stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK)
    GObject.io_add_watch(stdout, GObject.IO_HUP|GObject.IO_IN,
                         self.handle_naksu, os.fdopen(stdout))


  def handle_naksu(self, fd, condition, channel):
    try:
      if condition & GObject.IO_IN:
        channel.read()

      if condition & GObject.IO_HUP:
        channel.close()
        (pid, status) = os.waitpid(self.naksu_pid, 0)
        if status != 0:
          print("naksu pid %d returned exit status %s" % (pid, status),
                file=sys.stderr)

        time.sleep(3)
        self.run_naksu()

    except Exception as e:
      print("error when handling naksu: %s" % e, file=sys.stderr)
      return False

    return True


  def update_passwords(self):
    error = None
    try:
      with open(EXAMS_JSON_FILE) as file:
        new_exams = json.load(file)
        if (self.old_exams != new_exams):
          self.update_passwords_in_ui(new_exams)
        self.old_exams = new_exams
    except OSError as e:
      if e.errno != errno.EEXIST:
        error = e
    except Exception as e:
      error = e

    if error:
      # XXX should user be notified?
      print('error when updating passwords: %s' % error, file=sys.stderr)

    return True


  def update_passwords_in_ui(self, new_exams):
    self.exams_by_widgets = {}
    for button in self.password_buttons:
      button.destroy()

    for exam in new_exams:
      label = "%s (%s)" % (exam['decrypt_code'], exam['file_name'])
      button = Gtk.MenuItem(label)
      self.exams_by_widgets[button] = exam
      button.connect('activate', self.copy_password_to_clipboard)
      button.show()
      self.menu.append(button)
      self.password_buttons.append(button)


  def copy_password_to_clipboard(self, widget):
    password = self.exams_by_widgets[widget]['decrypt_code']
    self.clipboard.set_text(password, -1)


class PuavoErsExamSync (threading.Thread):
  def __init__(self):
    threading.Thread.__init__(self)

    with open('/etc/puavo/domain') as f:
      self.domain = f.read().rstrip()
    with open('/etc/puavo/hostname') as f:
      self.hostname = f.read().rstrip()
    with open('/etc/puavo/id') as f:
      self.id = f.read().rstrip()
    with open('/etc/puavo/ldap/dn') as f:
      self.ldap_dn = f.read().rstrip()
    with open('/etc/puavo/ldap/password') as f:
      self.ldap_password = f.read().rstrip()


  def run(self):
     while True:
       self.sync_exams()
       time.sleep(60)


  def sync_exams(self):
    self.exam_server_address = puavoconf_get('puavo.abitti.exam_server')
    index_uri = 'https://%s/schedules/query_exam_server_schedule' \
                   % self.exam_server_address

    response = requests.get(index_uri,
                            auth=HTTPBasicAuth(self.ldap_dn,
                                               self.ldap_password),
                            params={
                              'domain':   self.domain,
                              'hostname': self.hostname,
                              'id':       self.id,
                            })
    if not response:
      print('error when getting exam index from %s: %s' \
              % (index_uri, response.status_code), file=sys.stderr)
      return

    exams_json = response.content.decode('utf-8')
    self.update_exams_json_on_disk(exams_json)

    exam_names = []
    for exam in json.loads(exams_json):
      exam_file_name = exam['file_name']
      if not isinstance(exam_file_name, str):
        print('could not determine exam filename', file=sys.stderr)
      if exam_file_name == '':
        print('could not determine exam filename', file=sys.stderr)

      exam_names.append(exam_file_name)
      try:
        self.sync_one_exam(exam_file_name, exam)
      except Exception as e:
        print('error in syncing one exam: %s' % e, file=sys.stderr)

    # clean up old exams that no longer belong to exams subdirectories
    for exam_date_dir in glob.glob( os.path.join(EXAMS_DIR, '*') ):
      for exam_path in glob.glob( os.path.join(exam_date_dir, '*.meb') ):
        if not os.path.basename(exam_path) in exam_names:
          rm_f(exam_path)
      try:
        os.rmdir(exam_date_dir)
      except OSError as e:
        if e.errno != errno.ENOTEMPTY and e.errno != errno.ENOENT:
          raise e


  def update_exams_json_on_disk(self, exams_json):
    try:
      tmpfile = '%s.tmp' % EXAMS_JSON_FILE
      with open(tmpfile, 'w') as f:
        f.write(exams_json)
      os.rename(tmpfile, EXAMS_JSON_FILE)
    except Exception as e:
      # XXX should user be notified?
      print('error in writing passwords to %s: %s' % (EXAMS_JSON_FILE, e))


  def sync_one_exam(self, exam_file_name, exam):
    exam_start_time = datetime.datetime.fromtimestamp(exam['start_time'])
    exam_start_date = exam_start_time.strftime('%Y-%m-%d')
    exam_date_dir = os.path.join(EXAMS_DIR, exam_start_date)

    try:
      os.mkdir(exam_date_dir)
    except OSError as e:
      if e.errno != errno.EEXIST:
        raise e

    exam_file_path = os.path.join(exam_date_dir, exam_file_name)
    if os.path.isfile(exam_file_path):
      return

    exam_hash = exam['file_sha256']
    if not isinstance(exam_hash, str):
      raise Exception('could not determine exam hash for %s' % exam_file_name)

    exam_uri = 'https://%s/exams/raw_file' % self.exam_server_address

    response = requests.get(exam_uri,
                            auth=HTTPBasicAuth(self.ldap_dn,
                                               self.ldap_password),
                            params={
                              'domain':   self.domain,
                              'hash':     exam_hash,
                              'hostname': self.hostname,
                              'id':       self.id,
                            })
    if not response:
      raise Exception('error when getting an exam from %s: %s' \
              % (exam_uri, response.status_code))

    tmpfile = '%s.tmp' % exam_file_path
    with open(tmpfile, 'wb') as f:
      f.write(response.content)
    os.rename(tmpfile, exam_file_path)


class PuavoErsExamZipper (threading.Thread):
  def __init__(self):
    threading.Thread.__init__(self)

    self.previous_meb_files_by_date = {}


  def run(self):
    while True:
      self.current_date = datetime.date.today().strftime('%Y-%m-%d')
      self.zip_exams()
      self.link_exams_for_today()
      self.link_exam_dates_to_dirs()
      time.sleep(10)


  def link_exam_dates_to_dirs(self):
    archive_dates = []
    upcoming_dates = []

    # sort all exam date directories to archives or upcoming

    exam_dirs_by_date = glob.glob( os.path.join(EXAMS_DIR, '*') )
    for exam_dir in exam_dirs_by_date:
      exam_date = os.path.basename(exam_dir)
      if exam_date < self.current_date:
        archive_dates.append(exam_date)
      elif exam_date > self.current_date:
        upcoming_dates.append(exam_date)

    # remove obsolete ones

    for path in glob.glob( os.path.join(EXAMS_ARCHIVE_DIR, '*') ):
      exam_date = os.path.basename(path)
      if not exam_date in archive_dates:
        rm_f(path)

    for path in glob.glob( os.path.join(EXAMS_UPCOMING_DIR, '*') ):
      exam_date = os.path.basename(path)
      if not exam_date in upcoming_dates:
        rm_f(path)

    # link new or missing

    for exam_date in archive_dates:
      path = os.path.join(EXAMS_ARCHIVE_DIR, exam_date)
      if not os.path.islink(path):
        os.symlink(os.path.join('..', '.exams', exam_date),
                   path)

    for exam_date in upcoming_dates:
      path = os.path.join(EXAMS_UPCOMING_DIR, exam_date)
      if not os.path.islink(path):
        os.symlink(os.path.join('..', '.exams', exam_date),
                   path)


  def link_exams_for_today(self):
    todays_dir = os.path.join(EXAMS_DIR, self.current_date)
    should_be_exams_of_today = glob.glob( os.path.join(todays_dir, '*.meb') )
    current_exams_of_today = glob.glob( os.path.join(KTP_JAKO_DIR, '*.meb') )

    for current_exam_path in current_exams_of_today:
      should_be_exam_path = os.path.join(todays_dir,
                                         os.path.basename(current_exam_path))
      if not os.path.isfile(should_be_exam_path):
        rm_f(current_exam_path)

    for should_be_exam_path in should_be_exams_of_today:
      current_exam_path = os.path.join(KTP_JAKO_DIR,
                                       os.path.basename(should_be_exam_path))
      if not os.path.isfile(current_exam_path):
        try:
          os.link(should_be_exam_path, current_exam_path)
        except OSError as e:
          if e.errno != errno.EEXIST:
            raise e

    current_all_zip = os.path.join(KTP_JAKO_DIR,
                                   'Kaikki-%s.zip' % self.current_date)
    should_be_all_zip = os.path.join(todays_dir,
                                     'Kaikki-%s.zip' % self.current_date)

    if os.path.isfile(should_be_all_zip):
      if not os.path.isfile(current_all_zip) \
        or not filecmp.cmp(should_be_all_zip, current_all_zip):
          rm_f(current_all_zip)
          os.link(should_be_all_zip, current_all_zip)

    for all_zip in glob.glob( os.path.join(KTP_JAKO_DIR, 'Kaikki-*.zip') ):
      if all_zip != current_all_zip:
        rm_f(all_zip)


  def zip_exams(self):
    exam_dirs_by_date = glob.glob( os.path.join(EXAMS_DIR, '*') )

    for exam_dir_with_date in exam_dirs_by_date:
      meb_files = glob.glob( os.path.join(exam_dir_with_date, '*.meb') )
      meb_files.sort()

      exams_date = os.path.basename(exam_dir_with_date)
      all_zip_path = os.path.join(exam_dir_with_date,
                                  'Kaikki-%s.zip' % exams_date)

      if not exams_date in self.previous_meb_files_by_date:
        self.previous_meb_files_by_date[exams_date] = []

      if not os.path.exists(all_zip_path) \
        or meb_files != self.previous_meb_files_by_date[exams_date]:
          try:
            os.remove(all_zip_path)
          except FileNotFoundError:
            pass

          if len(meb_files) > 0:
            try:
              subprocess.check_output([ 'zip', '-j', all_zip_path ] + meb_files)
            except Exception as e:
              print('error when zipping exam files to %s: %s' \
                      % (all_zip_path, meb_files), file=sys.stderr)

      self.previous_meb_files_by_date[exams_date] = meb_files


applet = PuavoErsApplet()

for dir in [ KTP_JAKO_DIR, EXAMS_DIR, EXAMS_ARCHIVE_DIR, EXAMS_UPCOMING_DIR ]:
  try:
    os.mkdir(dir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise e

if __name__ == '__main__':
  signal.signal(signal.SIGINT, signal.SIG_DFL)
  applet.main()
