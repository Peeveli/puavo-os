#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import datetime
import errno
import fcntl
import filecmp
import gettext
import gi
import glob
import json
import os
import re
import requests
import shutil
import signal
import subprocess
import sys
import syslog
import threading
import time

gi.require_version('AppIndicator3', '0.1')
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')

from gi.repository import AppIndicator3
from gi.repository import Gdk
from gi.repository import Gio
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Gtk
from gi.repository import Notify

from requests.auth import HTTPBasicAuth

gettext.bindtextdomain('puavo-ers-applet', '/usr/share/locale')
gettext.textdomain('puavo-ers-applet')
_tr = gettext.gettext

KTP_JAKO_DIR       = os.path.join(os.environ['HOME'], 'ktp-jako')
EXAMS_ARCHIVE_DIR  = os.path.join(KTP_JAKO_DIR, 'Arkisto')
EXAMS_DIR          = os.path.join(KTP_JAKO_DIR, '.exams')
EXAMS_JSON_FILE    = os.path.join(KTP_JAKO_DIR, '.exams.json')
EXAMS_UPCOMING_DIR = os.path.join(KTP_JAKO_DIR, 'Tulevat')

def rm_f(path):
  try:
    os.unlink(path)
    syslog.syslog(syslog.LOG_INFO, 'removed %s' % path)
  except OSError as e:
    if e.errno != errno.ENOENT:
      raise e


def puavoconf_get(puavoconf_key):
  return subprocess.check_output([ 'puavo-conf', puavoconf_key ]).rstrip() \
                   .decode('utf-8')


class PuavoErsApplet:
  NAKSU_ORIGIN_PATH = '/opt/abitti-naksu/naksu'
  PUAVO_ERS_DIR = os.path.join(os.environ['HOME'], '.puavo', 'puavo-ers')
  NAKSU_BIN_PATH = os.path.join(PUAVO_ERS_DIR, 'naksu')

  def __init__(self):
    self.indicator \
      = AppIndicator3.Indicator.new('puavo-ers-applet',
          '/usr/share/icons/Faenza/emblems/64/emblem-default.png',
          AppIndicator3.IndicatorCategory.SYSTEM_SERVICES)
    self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

    self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)

    # XXX do we need this?
    Notify.init('puavo-ers-applet')

    os.makedirs(self.PUAVO_ERS_DIR, exist_ok=True)

    self.menu = Gtk.Menu()
    self.old_exams = []
    self.password_buttons = []

    self.indicator.set_menu(self.menu)

    instructions = Gtk.MenuItem(
                     _tr('click passphrase below put it into clipboard'))
    instructions.set_sensitive(False)
    self.menu.append(instructions)
    separator = Gtk.SeparatorMenuItem()
    self.menu.append(separator)
    self.latest_chosen_password = None

    self.menu.show_all()

    self.exam_sync = PuavoErsExamSync()
    self.exam_sync.start()

    self.exam_zipper = PuavoErsExamZipper()
    self.exam_zipper.start()

    if not os.path.exists(self.NAKSU_BIN_PATH):
      shutil.copy2(self.NAKSU_ORIGIN_PATH, self.NAKSU_BIN_PATH)


  def main(self):
    self.run_naksu()
    GObject.timeout_add_seconds(1, self.update_passwords)
    Gtk.main()


  def run_naksu(self):
    syslog.syslog(syslog.LOG_NOTICE, 'starting up naksu')

    cmd = [ '/usr/bin/terminator', '-T', 'naksu terminal',
            '--working-directory=' + self.PUAVO_ERS_DIR,
            '-x', './naksu', '--self-update=enabled' ]
    (pid, stdin, stdout, stderr) = GObject.spawn_async(cmd,
      flags=GLib.SPAWN_DO_NOT_REAP_CHILD|GLib.SPAWN_STDERR_TO_DEV_NULL,
      standard_input=True, standard_output=True)

    self.naksu_pid = pid

    fl = fcntl.fcntl(stdout, fcntl.F_GETFL)
    fcntl.fcntl(stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK)
    GObject.io_add_watch(stdout, GObject.IO_HUP|GObject.IO_IN,
                         self.handle_naksu, os.fdopen(stdout))


  def handle_naksu(self, fd, condition, channel):
    try:
      if condition & GObject.IO_IN:
        channel.read()

      if condition & GObject.IO_HUP:
        channel.close()
        (pid, status) = os.waitpid(self.naksu_pid, 0)
        if status != 0:
          syslog.syslog(syslog.LOG_ERR,
                        'naksu pid %d returned exit status %s' % (pid, status))
        else:
          syslog.syslog(syslog.LOG_NOTICE, 'naksu exited with success')

        time.sleep(3)
        self.run_naksu()

    except Exception as e:
      syslog.syslog(syslog.LOG_ERR, 'error when handling naksu: %s' % e)
      return False

    return True


  def update_passwords(self, force_update=False):
    error = None
    try:
      with open(EXAMS_JSON_FILE) as file:
        new_exams = json.load(file)
        if (force_update or self.old_exams != new_exams):
          self.update_passwords_in_ui(new_exams)
        self.old_exams = new_exams
    except OSError as e:
      if e.errno != errno.ENOENT:
        error = e
    except Exception as e:
      error = e

    if error:
      # XXX should user be notified?
      syslog.syslog(syslog.LOG_ERR, 'error when updating passwords: %s' % error)

    return True


  def update_passwords_in_ui(self, new_exams):
    syslog.syslog(syslog.LOG_INFO, 'updating passwords in UI')

    self.exams_by_widgets = {}
    for button in self.password_buttons:
      button.destroy()

    labels = {}
    for exam in new_exams:
      if not re.match('^exam_.*\.meb$', exam['file_name']):
        syslog.syslog(syslog.LOG_WARNING,
          'not showing password for exam %s' % exam['file_name'])
        continue

      # do not show passwords for old exams
      exam_end_time = datetime.datetime.fromtimestamp(exam['end_time'])
      if exam_end_time < datetime.datetime.now():
        continue

      label = "%s (%s)" % (exam['decrypt_code'], exam['file_name'])
      # Exams may have duplicates, in case there is one exam with multiple
      # start_time/end_times.  Weed out duplicates based on labels.
      if label in labels:
        continue
      labels[label] = 1

      if exam['decrypt_code'] == self.latest_chosen_password:
        label = '***** %s *****' % label

      button = Gtk.MenuItem(label)
      self.exams_by_widgets[button] = exam
      button.connect('activate', self.copy_password_to_clipboard)
      button.show()
      self.menu.append(button)
      self.password_buttons.append(button)


  def copy_password_to_clipboard(self, widget):
    syslog.syslog(syslog.LOG_INFO, 'copying password to clipboard')

    password = self.exams_by_widgets[widget]['decrypt_code']
    self.clipboard.set_text(password, -1)
    self.latest_chosen_password = password
    self.update_passwords(True)


class PuavoErsExamSync (threading.Thread):
  def __init__(self):
    threading.Thread.__init__(self)

    with open('/etc/puavo/domain') as f:
      self.domain = f.read().rstrip()
    with open('/etc/puavo/hostname') as f:
      self.hostname = f.read().rstrip()
    with open('/etc/puavo/id') as f:
      self.id = f.read().rstrip()
    with open('/etc/puavo/ldap/dn') as f:
      self.ldap_dn = f.read().rstrip()
    with open('/etc/puavo/ldap/password') as f:
      self.ldap_password = f.read().rstrip()


  def run(self):
     while True:
       self.sync_exams()
       time.sleep(60)


  def sync_exams(self):
    self.exam_server_address = puavoconf_get('puavo.abitti.exam_server')
    index_uri = 'https://%s/v1/schedules/query_exam_server_schedule' \
                   % self.exam_server_address

    syslog.syslog(syslog.LOG_INFO, 'checking for new exams from %s' % index_uri)

    response = requests.get(index_uri,
                            auth=HTTPBasicAuth(self.ldap_dn,
                                               self.ldap_password),
                            params={
                              'domain':   self.domain,
                              'hostname': self.hostname,
                              'id':       self.id,
                            })
    if not response:
      syslog.syslog(syslog.LOG_ERR,
        'error when getting exam index from %s: %s' \
          % (index_uri, response.status_code))
      return

    exams_json = response.content.decode('utf-8')
    self.update_exams_json_on_disk(exams_json)

    exam_name_list = []
    for exam in json.loads(exams_json):
      try:
        exam_file_name = exam['file_name']
        if not isinstance(exam_file_name, str):
          raise Exception('could not determine exam filename')
        if exam_file_name == '':
          raise Exception('could not determine exam filename')
        if not re.match('^exam_.*\.meb$', exam_file_name):
          raise Exception('not syncing exam with a filename %s' \
                            % exam_file_name)

        self.sync_one_exam(exam_file_name, exam)
        exam_name_list.append(exam_file_name)
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, 'error in syncing one exam: %s' % e)

    # clean up old exams that no longer belong to exams subdirectories
    for exam_path in glob.glob( os.path.join(EXAMS_DIR, 'exam_*.meb') ):
      if not os.path.basename(exam_path) in exam_name_list:
        # We check that file hard link count must be over 1, in which case
        # it has already been archived and we can delete it here.
        if os.stat(exam_path).st_nlink > 1:
          rm_f(exam_path)


  def update_exams_json_on_disk(self, exams_json):
    try:
      tmpfile = '%s.tmp' % EXAMS_JSON_FILE
      with open(tmpfile, 'w') as f:
        f.write(exams_json)
      os.rename(tmpfile, EXAMS_JSON_FILE)
    except Exception as e:
      # XXX should user be notified?
      syslog.syslog(syslog.LOG_CRIT,
        'error in writing passwords to %s: %s' % (EXAMS_JSON_FILE, e))


  def sync_one_exam(self, exam_file_name, exam):
    exam_file_path = os.path.join(EXAMS_DIR, exam_file_name)
    if os.path.isfile(exam_file_path):
      return

    syslog.syslog(syslog.LOG_NOTICE, 'syncing exam %s' % exam_file_name)

    exam_hash = exam['file_sha256']
    if not isinstance(exam_hash, str):
      raise Exception('could not determine exam hash for %s' % exam_file_name)

    exam_uri = 'https://%s/v1/exams/raw_file' % self.exam_server_address

    response = requests.get(exam_uri,
                            auth=HTTPBasicAuth(self.ldap_dn,
                                               self.ldap_password),
                            params={
                              'domain':   self.domain,
                              'hash':     exam_hash,
                              'hostname': self.hostname,
                              'id':       self.id,
                            })
    if not response:
      raise Exception('error when getting an exam from %s: %s' \
              % (exam_uri, response.status_code))

    tmpfile = '%s.tmp' % exam_file_path
    with open(tmpfile, 'wb') as f:
      f.write(response.content)
    os.rename(tmpfile, exam_file_path)

    syslog.syslog(syslog.LOG_INFO, 'exam %s synced okay' % exam_file_name)


class PuavoErsExamZipper (threading.Thread):
  def __init__(self):
    threading.Thread.__init__(self)

    self.previous_meb_files_in_all_zip = []


  def run(self):
    while True:
      try:
        self.sort_exams_to_dirs()
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, 'some error when sorting exams: %s' % e)

      time.sleep(10)


  def sort_exams_to_dirs(self):
    self.current_time = datetime.datetime.now()
    try:
      with open(EXAMS_JSON_FILE) as file:
        current_exams = json.load(file)
    except OSError as e:
      if e.errno != errno.ENOENT:
        raise e
      return

    archived_exams          = []
    currently_running_exams = []
    upcoming_exams          = []

    for exam in current_exams:
      try:
        if not re.match('^exam_.*\.meb$', exam['file_name']):
          raise Exception('ignoring exam with a file name %s' \
                            % exam['file_name'])

        exam_start_time = datetime.datetime.fromtimestamp(exam['start_time'])
        exam_end_time   = datetime.datetime.fromtimestamp(exam['end_time'])

        if exam_end_time < self.current_time:
          archived_exams.append(exam['file_name'])
        elif self.current_time < exam_start_time:
          upcoming_exams.append(exam['file_name'])
        elif exam_start_time <= self.current_time \
          and self.current_time < exam_end_time:
            currently_running_exams.append(exam['file_name'])
      except Exception as e:
        syslog.syslog(syslog.LOG_ERR, 'could not handle an exam: %s' % e)

    self.link_exams_to_dir(EXAMS_ARCHIVE_DIR, archived_exams,
                           remove_other=False)
    self.link_exams_to_dir(KTP_JAKO_DIR, currently_running_exams)
    self.zip_todays_exams()
    self.link_exams_to_dir(EXAMS_UPCOMING_DIR, upcoming_exams)


  def link_exams_to_dir(self, linkdir, exam_names_list, remove_other=True):
    if remove_other:
      for path in glob.glob( os.path.join(linkdir, 'exam_*.meb') ):
        if not os.path.basename(path) in exam_names_list:
          rm_f(path)

    for exam_name in exam_names_list:
      try:
        os.link(os.path.join(EXAMS_DIR, exam_name),
                os.path.join(linkdir, exam_name))
        syslog.syslog(syslog.LOG_INFO,
                      'exam %s linked to %s' % (exam_name, linkdir))
      except OSError as e:
        if e.errno != errno.EEXIST:
          raise e


  def zip_todays_exams(self):
    meb_files = glob.glob( os.path.join(KTP_JAKO_DIR, 'exam_*.meb') )
    meb_files.sort()

    current_date = self.current_time.strftime('%Y-%m-%d')
    current_all_zip_path = os.path.join(KTP_JAKO_DIR,
                                        'Kaikki-%s.zip' % current_date)

    if len(meb_files) == 0:
      rm_f(current_all_zip_path)
    elif not os.path.exists(current_all_zip_path) \
      or meb_files != self.previous_meb_files_in_all_zip:
        rm_f(current_all_zip_path)
        try:
          syslog.syslog(syslog.LOG_INFO,
            'zipping exams %s into %s' % (meb_files, current_all_zip_path))
          subprocess.check_output([ 'zip', '-j', current_all_zip_path ] \
                                    + meb_files)
        except Exception as e:
          syslog.syslog(syslog.LOG_ERR,
            'error when zipping exam files to %s: %s' \
              % (current_all_zip_path, meb_files))

    self.previous_meb_files_in_all_zip = meb_files

    all_zip_files = glob.glob( os.path.join(KTP_JAKO_DIR, 'Kaikki-*.zip') )
    for zipfile in all_zip_files:
      if current_all_zip_path != zipfile:
        rm_f(zipfile)


syslog.openlog('puavo-ers-applet')

syslog.syslog(syslog.LOG_NOTICE, 'puavo-ers-applet starting up')

applet = PuavoErsApplet()

for dir in [ KTP_JAKO_DIR, EXAMS_DIR, EXAMS_ARCHIVE_DIR, EXAMS_UPCOMING_DIR ]:
  try:
    os.mkdir(dir)
  except OSError as e:
    if e.errno != errno.EEXIST:
      raise e

if __name__ == '__main__':
  signal.signal(signal.SIGINT, signal.SIG_DFL)
  applet.main()

syslog.closelog()
