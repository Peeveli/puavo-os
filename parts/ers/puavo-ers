#!/usr/bin/wish

package require http
package require json
package require tls

::http::register https 443 ::tls::socket

set exam_server_address [exec puavo-conf puavo.abitti.exam_server]
if {$exam_server_address eq ""} {
  exit 0
}

wm attributes . -topmost 1
wm attributes . -type notification

set exam_sharedir "$env(HOME)/ktp-jako"
set vagrant_process_fh ""

set previous_window_placement "bottom"

set vagrantfile {
  # -*- mode: ruby -*-
  # vi: set ft=ruby :

  require 'facter'
  require 'getoptlong'

  opts = GetoptLong.new(
    [ '--abitti-version',  GetoptLong::REQUIRED_ARGUMENT ],
    [ '--network-adapter', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--prepare',         GetoptLong::NO_ARGUMENT       ],
    [ '--server-version',  GetoptLong::REQUIRED_ARGUMENT ],
    [ '--virtual-box-url', GetoptLong::REQUIRED_ARGUMENT ],
  )

  abitti_version  = nil
  network_adapter = nil
  prepare         = false
  server_version  = nil
  virtual_box_url = nil

  opts.each do |opt, arg|
    case opt
      when '--abitti-version'
        abitti_version = arg.sub(/^abitti-v/, '')
      when '--network-adapter'
        network_adapter = arg
      when '--prepare'
        prepare = true
      when '--server-version'
        server_version = arg
      when '--virtual-box-url'
        virtual_box_url = arg
    end
  end

  cpus = [ 1, Facter['processorcount'].value.to_i - 1 ].max
  mem  = (0.75 * Facter['memorysize_mb'].value.to_i).to_i

  # All Vagrant configuration is done below. The "2" in Vagrant.configure
  # configures the configuration version (we support older styles for
  # backwards compatibility). Please don't change it unless you know what
  # you're doing.
  Vagrant.configure('2') do |config|
    config.vm.boot_timeout = 1
    config.vm.box = "digabi/ktp-qa-abitti-v#{ abitti_version }"
    config.vm.box_url = virtual_box_url
    config.vm.provider :virtualbox do |vb|
      vb.name = server_version
      vb.gui = (prepare ? false : true)
      vb.customize [ 'modifyvm',     :id, '--ioapic',       'on'            ]
      vb.customize [ 'modifyvm',     :id, '--cpus',         cpus            ]
      vb.customize [ 'modifyvm',     :id, '--memory',       mem             ]
      vb.customize [ 'modifyvm',     :id, '--nictype1',     'virtio'        ]
      vb.customize [ 'modifyvm',     :id, '--clipboard',    'bidirectional' ]
      vb.customize [ 'modifyvm',     :id, '--vram',          24             ]
      vb.customize [ 'modifyvm',     :id, '--description',  'digabi/ktp-qa' ]

      vb.customize [ 'setextradata', 'global', 'GUI/MenuBar/Enabled', 'false' ]
      vb.customize [ 'setextradata', 'global', 'GUI/StatusBar/Enabled',
                                               'false' ]
      vb.customize [ 'setextradata',
                     'global',
                     'GUI/SuppressMessages',
                     %w(confirmGoingFullscreen
                        remindAboutAutoCapture
                        remindAboutMouseIntegration).join(',') ]
    end

    config.vm.synced_folder '~/ktp-jako', '/media/usb1', id: 'media_usb1'
    config.vm.network 'public_network',
                      :adapter => 1,
                      bridge: network_adapter,
                      auto_config: false
  end
}

proc logger {msg} {
  catch { exec logger -t puavo-ers $msg }
}

proc abitti_version_num {abitti_version} {
  if {![regsub -- {^abitti-v(\d+)$} $abitti_version {\1} abitti_version_num]} {
    error "bad abitti version number in $abitti_version"
  }
  return $abitti_version_num
}

proc write_file {filepath data} {
  set fd ""
  try {
    set fd [open "${filepath}.tmp" w]
    puts -nonewline $fd $data
    file rename -force "${filepath}.tmp" $filepath
  } on error {errmsg} {
    logger "error in writing $filepath: $errmsg"
  } finally {
    if {$fd ne ""} { close $fd }
  }
}

proc handle_vagrant_output {abitti_version mode} {
  global ers_basedir vagrant_process_fh

  set count [gets $vagrant_process_fh line]
  if {$count > 0} {
    set line_no_cntrl [regsub -all {[[:cntrl:]]\[K} $line ""]
    set message "Abitti [abitti_version_num $abitti_version]: $line_no_cntrl"
    logger "vagrant: $message"
    .startup.activity configure -text $message
  }

  if {[eof $vagrant_process_fh]} {
    fconfigure $vagrant_process_fh -blocking 1
    if {[catch { close $vagrant_process_fh } errmsg]} {
      logger "vagrant for $abitti_version (mode=$mode) returned error: $errmsg"
    } else {
      logger "vagrant for $abitti_version returned successfully"
    }

    set vagrant_process_fh ""

    switch -- $mode {
      prepare_and_start {
        manage_virtual_machine start $abitti_version
      }
      prepare {
        set ers_dir "${ers_basedir}/${abitti_version}"
        cd $ers_dir
        catch { exec vagrant halt }
        # after five minutes try preparing next virtual machine
        after 300000 trigger_next_virtual_machine
      }
      start {
        show_passwords_on_window
        # after five minutes try preparing next virtual machine
        after 300000 trigger_next_virtual_machine
      }
    }
  }
}

proc manage_virtual_machine {mode abitti_version} {
  global abitti_config ers_basedir vagrant_process_fh

  logger "running vagrant for virtual machine $abitti_version (mode=$mode)"

  set network_adapter "eth0"
  set server_version [dict get $abitti_config server $abitti_version \
                                                     server_version]
  set virtual_box_url [dict get $abitti_config server $abitti_version \
                                                      virtual_box_url]
  set vagrant_args [list --abitti-version=${abitti_version}   \
                         --network-adapter=${network_adapter} \
                         --server-version=${server_version}   \
                         --virtual-box-url=${virtual_box_url}]

  switch -- $mode {
    prepare_and_start -
    prepare { lappend vagrant_args --prepare }
    start   {}
  }

  set ers_dir "${ers_basedir}/${abitti_version}"
  update_vagrantfile $ers_dir
  cd $ers_dir
  set vagrant_process_fh [open "|[list vagrant {*}$vagrant_args up]"]

  fconfigure $vagrant_process_fh -blocking 0
  fileevent $vagrant_process_fh readable [
    list handle_vagrant_output $abitti_version $mode
  ]
}

proc read_file {path} {
  set f [open $path]
  try {
    set data [read $f]
  } finally {
    close $f
  }
  return [string trimright $data "\n"]
}

proc show_passwords_on_window {} {
  pack forget .startup
  pack .passwords -expand 1 -fill both -side left
  pack .close_button -fill y -expand 1 -side right

  logger "showing passwords on window (if there are any)"

  wm minsize . 64 36

  bind .passwords <Enter> { set_window_placement change }

  update_passwords_on_window
}

proc there_is_a_virtual_machine_running {} {
  expr { [exec VBoxManage list runningvms] ne "" ? "true" : "false" }
}

proc ensure_there_is_a_virtual_machine_running {} {
  catch {
    if {![there_is_a_virtual_machine_running]} {
      trigger_next_virtual_machine
    }
  }

  after 15000 ensure_there_is_a_virtual_machine_running
}

proc trigger_next_virtual_machine {} {
  global abitti_config abitti_json_path env vagrant_process_fh

  if {$vagrant_process_fh ne ""} {
    return
  }

  set abitti_config [json::json2dict [read_file $abitti_json_path]]

  set target_abitti_version [exec puavo-conf puavo.abitti.version]
  if {$target_abitti_version eq "latest"} {
    set target_abitti_version [dict get $abitti_config latest]
  }
  if {![dict exists $abitti_config server $target_abitti_version]} {
    tk_messageBox -icon error \
      -message "requested an unknown abitti version: $target_abitti_version"
  }

  set target_abitti_version_num [abitti_version_num $target_abitti_version]

  set abitti_version_list [lsort -dictionary \
                                 [dict keys [dict get $abitti_config server]]]

  set installed_versions [dict create]
  set latest_installed_version     ""
  set next_to_be_installed_version ""

  foreach abitti_version $abitti_version_list {
    set abitti_version_num [abitti_version_num $abitti_version]
    set server_version [dict get $abitti_config server $abitti_version \
                                                       server_version]

    if {[file exists "$env(HOME)/VirtualBox VMs/${server_version}"]} {
      dict set installed_versions $abitti_version 1
      set latest_installed_version $abitti_version
    } elseif {$target_abitti_version ne $next_to_be_installed_version
                && $abitti_version_num >= $target_abitti_version_num} {
      set next_to_be_installed_version $abitti_version
    }
  }

  set version_to_start ""
  if {[dict exists $installed_versions $target_abitti_version]} {
    set version_to_start $target_abitti_version
  } elseif {$latest_installed_version ne ""} {
    set version_to_start $latest_installed_version
  }

  if {$version_to_start ne "" && ![there_is_a_virtual_machine_running]} {
    manage_virtual_machine start $version_to_start
    return
  }

  if {$next_to_be_installed_version ne ""} {
    if {$next_to_be_installed_version eq $target_abitti_version
          && ![there_is_a_virtual_machine_running]} {
      manage_virtual_machine prepare_and_start $next_to_be_installed_version
    } else {
      manage_virtual_machine prepare $next_to_be_installed_version
    }
  }
}

proc update_abitti_json {abitti_json_path} {
  catch {
    logger "downloading $abitti_json_path"
    exec wget -q --ca-certificate=/etc/puavo/certs/rootca.pem --timeout=15 \
              -O "${abitti_json_path}.tmp" \
              https://images.opinsys.fi/abitti-images/abitti.json
    file rename -force "${abitti_json_path}.tmp" $abitti_json_path
    logger "updated $abitti_json_path"
  }

  if {[file exists $abitti_json_path]} {
    trigger_next_virtual_machine
    set next_try_in_ms 3600000; # lookup abitti.json every hour
  } else {
    set next_try_in_ms 60000;   # lookup abitti.json every minute
  }

  after $next_try_in_ms [list update_abitti_json $abitti_json_path]
}

proc find_files {args} {
  lmap _ [split [exec find {*}$args -print0] "\0"] \
         { expr { $_ ne "" ? $_ : [continue] } }
}

proc update_all_exams_pack {} {
  global exam_sharedir old_exam_share_meb_paths

  set exam_share_meb_paths [find_files $exam_sharedir -maxdepth 1 \
                                                      -name exam_*.meb]
  set all_zip_path "${exam_sharedir}/Kaikki.zip"
  if {![file exists $all_zip_path]
       || $old_exam_share_meb_paths ne $exam_share_meb_paths} {
    file delete $all_zip_path
    if {[llength $exam_share_meb_paths] > 0} {
      set msg "updating $all_zip_path with current exams:"
      set msg "${msg} [join $exam_share_meb_paths " / " ]"
      logger $msg
      exec zip -j $all_zip_path {*}$exam_share_meb_paths
    }
    set old_exam_share_meb_paths $exam_share_meb_paths
  }
}

proc update_all_exams_pack_loop {} {
  catch { update_all_exams_pack }
  after 3000 update_all_exams_pack_loop
}

proc update_exams_from_media {} {
  global env exam_sharedir old_media_meb_paths

  catch {
    set media_meb_paths [find_files "/media/$env(USER)" -name exam_*.meb]
    if {[llength $media_meb_paths] > 0} {
      if {$old_media_meb_paths ne $media_meb_paths} {
        # XXX do not delete exams for now, because some of the exams
        # XXX might come from the exam distribution server
        # logger "new exams in external media, deleting exams in $exam_sharedir"
        # catch { exec find $exam_sharedir -name exam_*.meb -delete }
        foreach meb_path $media_meb_paths {
          logger "copying an exam from $meb_path to $exam_sharedir"
          file copy -force $meb_path $exam_sharedir
        }
        update_all_exams_pack
      }
    }
    set old_media_meb_paths $media_meb_paths
  }

  after 3000 update_exams_from_media
}

proc handle_exams_index_fetch {token} {
  upvar #0 $token state
  global exam_server_address exam_sharedir

  if {[::http::ncode $token] ne 200} {
    logger "exam index fetch returned [::http::code $token]: $state(body)"
    return
  }

  logger "fetched exam index"

  # XXX we should also probably remove exams that are not
  # XXX scheduled on this time

  set passwords [list]

  set exam_list [::json::json2dict $state(body)]
  foreach exam $exam_list {
    # XXX we do not have passwords yet here
    # XXX lappend passwords [dict get $exam password]
    lappend passwords [dict get $exam hash]

    set exam_filename [dict get $exam file]
    set exam_uuid [dict get $exam uuid]

    # XXX maybe we should validate the exam filename a bit?
    if {[file exists "${exam_sharedir}/${exam_filename}"]} {
      continue
    }

    logger "exam $exam_filename ($exam_uuid) is missing, fetching it"

    ::http::geturl "https://${exam_server_address}/tests/1234/${exam_uuid}" \
                   -command [list handle_exam_fetch $exam]
  }

  set passwords_data [join [lmap _ $passwords { format "%s\n" $_ }] ""]
  write_file "${exam_sharedir}/.exam_passwords.txt" \
             $passwords_data
}

proc handle_exam_fetch {exam token} {
  upvar #0 $token state
  global exam_sharedir

  if {[::http::ncode $token] ne 200} {
    puts stderr "exam fetch returned [::http::code $token]: $state(body)"
    return
  }

  write_file "${exam_sharedir}/[dict get $exam file]" \
             $state(body)
}

proc update_exams_from_server {} {
  global exam_server_address

  catch {
    # XXX can this be executing twice at the same time?  no locking?
    ::http::geturl "https://${exam_server_address}/tests/1234" \
                   -command handle_exams_index_fetch
  }

  # XXX check the index again after one minute (!)
  after 60000 update_exams_from_server
}

proc set_window_placement {{placement keep}} {
  global previous_window_placement

  switch -- $placement {
    change {
      set placement [
        expr { $previous_window_placement eq "bottom" ? "up" : "bottom" }
      ]
    }
    keep { set placement $previous_window_placement }
  }

  set x [expr { ([winfo screenwidth  .] - [winfo width .]) }]
  set y [expr { $placement eq "bottom"
                  ? ([winfo screenheight .] - [winfo height .])
                  : 0 }]
  wm geometry . +$x+$y

  if {$placement ne $previous_window_placement} {
    logger "placing passwords window to $placement"
  }

  set previous_window_placement $placement
}

proc update_passwords_on_window {} {
  global exam_sharedir

  try {
    set passwords_text [read_file "${exam_sharedir}/.exam_passwords.txt"]
  } on error {} {
    logger "closing passwords window (because no passwords to show)"
    wm withdraw .
    return
  }

  .passwords configure -text $passwords_text

  after 100 set_window_placement
  after 5000 update_passwords_on_window
}

proc update_vagrantfile {ers_dir} {
  global vagrantfile

  exec mkdir -p $ers_dir

  set vagrant_fh [open "${ers_dir}/Vagrantfile" w]

  puts $vagrant_fh $vagrantfile
  close $vagrant_fh
}

logger "starting up puavo-ers"

set ers_basedir      "$env(HOME)/.puavo/puavo-ers"
set abitti_json_path "${ers_basedir}/abitti.json"

exec mkdir -p $ers_basedir $exam_sharedir

wm minsize . 700 36

frame .startup
label .startup.activity -text "Waiting vagrant..."
ttk::progressbar .startup.progressbar -length 100           \
                                      -mode   indeterminate \
                                      -orient horizontal
pack .startup.activity .startup.progressbar -fill both -expand 1
pack .startup -fill both -expand 1
.startup.progressbar start

# do not pack yet
label .passwords -anchor w -padx 20 -pady 4
button .close_button -text X -command {
  logger "closing passwords window because close button is pressed"
  wm withdraw .
}

set_window_placement bottom

# also triggers updates when successful:
update_abitti_json $abitti_json_path

set old_exam_share_meb_paths [list]
set old_media_meb_paths      [list]

update_exams_from_media
update_exams_from_server
update_all_exams_pack_loop
ensure_there_is_a_virtual_machine_running
