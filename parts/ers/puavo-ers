#!/usr/bin/wish

package require json

wm attributes . -type splash

set exam_sharedir "$env(HOME)/ktp-jako"
set we_have_abitti_json false

set vagrantfile {
  # -*- mode: ruby -*-
  # vi: set ft=ruby :

  require 'facter'
  require 'getoptlong'

  opts = GetoptLong.new(
    [ '--abitti-version',  GetoptLong::REQUIRED_ARGUMENT ],
    [ '--network-adapter', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--prepare',         GetoptLong::NO_ARGUMENT       ],
    [ '--server-version',  GetoptLong::REQUIRED_ARGUMENT ],
    [ '--virtual-box-url', GetoptLong::REQUIRED_ARGUMENT ],
  )

  abitti_version  = nil
  network_adapter = nil
  prepare         = false
  server_version  = nil
  virtual_box_url = nil

  opts.each do |opt, arg|
    case opt
      when '--abitti-version'
        abitti_version = arg.sub(/^abitti-v/, '')
      when '--network-adapter'
        network_adapter = arg
      when '--prepare'
        prepare = true
      when '--server-version'
        server_version = arg
      when '--virtual-box-url'
        virtual_box_url = arg
    end
  end

  cpus = [ 1, Facter['processorcount'].value.to_i - 1 ].max
  mem  = (0.75 * Facter['memorysize_mb'].value.to_i).to_i

  # All Vagrant configuration is done below. The "2" in Vagrant.configure
  # configures the configuration version (we support older styles for
  # backwards compatibility). Please don't change it unless you know what
  # you're doing.
  Vagrant.configure('2') do |config|
    config.vm.boot_timeout = 1
    config.vm.box = "digabi/ktp-qa-abitti-v#{ abitti_version }"
    config.vm.box_url = virtual_box_url
    config.vm.provider :virtualbox do |vb|
      vb.name = server_version
      vb.gui = (prepare ? false : true)
      vb.customize [ 'modifyvm',     :id, '--ioapic',       'on'            ]
      vb.customize [ 'modifyvm',     :id, '--cpus',         cpus            ]
      vb.customize [ 'modifyvm',     :id, '--memory',       mem             ]
      vb.customize [ 'modifyvm',     :id, '--nictype1',     'virtio'        ]
      vb.customize [ 'modifyvm',     :id, '--clipboard',    'bidirectional' ]
      vb.customize [ 'modifyvm',     :id, '--vram',          24             ]
      vb.customize [ 'modifyvm',     :id, '--description',  'digabi/ktp-qa' ]
      vb.customize [ 'setextradata', :id, 'GUI/Fullscreen', 'true'          ]

      vb.customize [ 'setextradata',
                     'global',
                     'GUI/SuppressMessages',
                     %w(confirmGoingFullscreen
                        remindAboutAutoCapture
                        remindAboutMouseIntegration).join(',') ]
    end

    config.vm.synced_folder '~/ktp-jako', '/media/usb1', id: 'media_usb1'
    config.vm.network 'public_network',
                      :adapter => 1,
                      bridge: network_adapter,
                      auto_config: false
  end
}

proc abitti_version_num {abitti_version} {
  if {![regsub -- {^abitti-v(\d+)$} $abitti_version {\1} abitti_version_num]} {
    error "bad abitti version number in $abitti_version"
  }
  return $abitti_version_num
}

proc get_version_gui {abitti_version} {
  set abitti_version_num [abitti_version_num $abitti_version]
  return ".abitti_v${abitti_version_num}"
}

proc handle_vagrant_output {vagrant_fh abitti_version mode} {
  global ers_basedir vagrant

  set gui [get_version_gui $abitti_version]

  set count [gets $vagrant_fh line]
  if {$count > 0} {
    set message "Abitti [abitti_version_num $abitti_version]: $line"
    puts $message
    ${gui}.activity configure -text $message
  }

  if {[eof $vagrant_fh]} {
    fconfigure $vagrant_fh -blocking 1
    if {[catch { close $vagrant_fh } errormsg]} {
      # XXX how to handle error?  should we show it?
      puts stderr "vagrant returned error:\n$errormsg"
    } else {
      puts "vagrant returned successfully"
    }
    switch -- $mode {
      prepare_and_start {
        manage_virtual_machine start $abitti_version
      }
      prepare {
        set ers_dir "${ers_basedir}/${abitti_version}"
        cd $ers_dir
        exec vagrant halt
      }
      start {
        wm withdraw .
      }
    }
  }
}

proc make_abitti_gui {abitti_version} {
  set gui [get_version_gui $abitti_version]

  frame $gui
  label ${gui}.activity -text "Waiting vagrant..."
  ttk::progressbar ${gui}.progressbar -length 100           \
                                      -mode   indeterminate \
                                      -orient horizontal

  # XXX should maybe use grid
  pack ${gui}.activity ${gui}.progressbar -fill both -expand 1 -side left

  ${gui}.progressbar start

  pack $gui
}

proc manage_virtual_machine {mode abitti_version} {
  global abitti_config env ers_basedir

  set network_adapter "eth0"
  set server_version [dict get $abitti_config server $abitti_version \
                                                     server_version]
  set virtual_box_url [dict get $abitti_config server $abitti_version \
                                                      virtual_box_url]
  set vm_dir "$env(HOME)/VirtualBox VMs/${server_version}"

  switch -- $mode {
    prepare_and_start {
      if {[file exists $vm_dir]} {
        set mode start
      } else {
        lappend vagrant_args --prepare
      }
    }
    prepare {
      if {[file exists $vm_dir]} {
        # already prepared
        return
      }
      lappend vagrant_args --prepare
    }
    start {}
  }

  set vagrant_args [list --abitti-version=${abitti_version}   \
                         --network-adapter=${network_adapter} \
                         --server-version=${server_version}   \
                         --virtual-box-url=${virtual_box_url}]

  set ers_dir "${ers_basedir}/${abitti_version}"
  update_vagrantfile $ers_dir
  cd $ers_dir
  set vagrant_fh [open "|[list vagrant {*}$vagrant_args up]"]

  fconfigure $vagrant_fh -blocking 0
  fileevent $vagrant_fh readable [
    list handle_vagrant_output $vagrant_fh $abitti_version $mode
  ]
}

proc read_file {path} {
  set f [open $path]
  try {
    set data [read $f]
  } finally {
    close $f
  }
  return [string trimright $data "\n"]
}

proc trigger_updates {} {
  global abitti_config abitti_json_path

  set abitti_config [json::json2dict [read_file $abitti_json_path]]

  set target_abitti_version [exec puavo-conf puavo.abitti.version]
  if {$target_abitti_version eq "latest"} {
    set target_abitti_version [dict get $abitti_config latest]
  }
  if {![dict exists $abitti_config server $target_abitti_version]} {
    tk_messageBox -icon error \
      -message "requested an unknown abitti version: $target_abitti_version"
  }

  set abitti_version_list [dict keys [dict get $abitti_config server]]

  # XXX should not try to do this if there is already something running
  # XXX for this version (should keep track of those)
  foreach abitti_version $abitti_version_list {
    make_abitti_gui $abitti_version
    if {$abitti_version eq $target_abitti_version} {
      manage_virtual_machine prepare_and_start $abitti_version
    } else {
      set abitti_version_num        [abitti_version_num $abitti_version]
      set target_abitti_version_num [abitti_version_num $target_abitti_version]
      if {$target_abitti_version_num < $abitti_version_num} {
        manage_virtual_machine prepare $abitti_version
      }
    }
  }
}

proc update_abitti_json {abitti_json_path} {
  global we_have_abitti_json

  catch {
    exec wget -q --ca-certificate=/etc/puavo/certs/rootca.pem \
              -O "${abitti_json_path}.tmp" \
              https://images.opinsys.fi/abitti-images/abitti.json
    file rename -force "${abitti_json_path}.tmp" $abitti_json_path
  }

  if {[file exists $abitti_json_path]} {
    set we_have_abitti_json true
    trigger_updates
    set next_try_in_ms 3600000; # lookup abitti.json every hour
  } else {
    set next_try_in_ms 60000;   # lookup abitti.json every minute
  }

  after $next_try_in_ms [list update_abitti_json $abitti_json_path]
}

proc update_all_exams_pack {} {
  global exam_sharedir old_exam_share_meb_paths

  catch {
    set exam_share_meb_paths [exec find $exam_sharedir -maxdepth 1 -name *.meb]
    if {$old_exam_share_meb_paths ne $exam_share_meb_paths} {
      set all_zip_path  "${exam_sharedir}/Kaikki.zip"
      file delete $all_zip_path
      if {[llength $exam_share_meb_paths] > 0} {
        exec zip $all_zip_path {*}$exam_share_meb_paths
      }
      set old_exam_share_meb_paths $exam_share_meb_paths
    }
  }

  after 3000 update_all_exams_pack
}

proc update_exams_from_media {} {
  global exam_sharedir old_media_meb_paths

  catch {
    set media_meb_paths [exec find "/media/$env(USER)" -name *.meb]
    if {$old_media_meb_paths ne $media_meb_paths} {
      foreach meb_path $media_meb_paths {
        file copy -force $meb_path $exam_sharedir
      }
      set old_media_meb_paths $media_meb_paths
    }
  }

  after 3000 update_exams_from_media
}

proc update_vagrantfile {ers_dir} {
  global vagrantfile

  exec mkdir -p $ers_dir

  set vagrant_fh [open "${ers_dir}/Vagrantfile" w]

  puts $vagrant_fh $vagrantfile
  close $vagrant_fh
}

set ers_basedir      "$env(HOME)/.puavo/puavo-ers"
set abitti_json_path "${ers_basedir}/abitti.json"

exec mkdir -p $ers_basedir $exam_sharedir

# also triggers updates when successful:
update_abitti_json $abitti_json_path

if {!$we_have_abitti_json} {
  # XXX we could show some error message here?
  # XXX perhaps allow user to retry?
  vwait we_have_abitti_json
}

set old_exam_share_meb_paths [list]
set old_media_meb_paths      [list]

update_all_exams_pack
update_exams_from_media
