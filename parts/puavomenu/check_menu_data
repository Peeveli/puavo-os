#!/usr/bin/python3

# Simple tool for checking syntax errors in menudata JSON files

import os
import logging
import time
import json
import argparse

import utils
import filters.tags
import filters.conditionals
import loaders.json_loader
import loaders.menudata_loader
import icon_cache


# Parse the command-line arguments
parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter)

parser.add_argument('--lang',
                    type=str,
                    required=False,
                    default='en',
                    help='language code')

parser.add_argument('--tags',
                    type=str,
                    required=False,
                    default='default',
                    help='tag filter string (if you need to use negation, ' \
                         'put whitespace at the start, like " -default")')

required = parser.add_argument_group('required arguments')

required.add_argument('--base_dir',
                      required=True,
                      type=str,
                      help='location of the menu data')

args = parser.parse_args()

if not os.path.isdir(args.base_dir):
    quit('ERROR: The directory "{0}" does not exist'.format(args.base_dir))

print('Loading menudata from "{0}"'.format(args.base_dir))
print('Pay attention to WARNING, ERROR and CRITICAL lines below')
print('=' * 50)

logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s',
                    level=logging.DEBUG)

logging.addLevelName(
    logging.WARNING, '\033[1;33m%s\033[0m' % logging.getLevelName(logging.WARNING))
logging.addLevelName(
    logging.ERROR, '\033[1;31m%s\033[0m' % logging.getLevelName(logging.ERROR))
logging.addLevelName(
    logging.CRITICAL, '\033[1;93;101m%s\033[0m' % logging.getLevelName(logging.CRITICAL))


dirs_file = os.path.join(args.base_dir, 'dirs.json')

logging.info('Loading directory configuration file "%s"', dirs_file)

desktop_dirs = []
icon_dirs = []

try:
    with open(dirs_file, 'r', encoding='utf-8') as dirs_file:
        dirs = json.load(dirs_file)

    if 'desktop_dirs' in dirs:
        desktop_dirs = dirs['desktop_dirs']

    if 'icon_dirs' in dirs:
        icon_dirs = dirs['icon_dirs']
except Exception as exception:
    logging.fatal('Failed to load the directories config file "%s": %s',
                  dirs_file, str(exception))


conditional_dirs = [os.path.join(args.base_dir, 'conditions')]
menudata_dirs = [os.path.join(args.base_dir, 'menudata')]

start_time = time.perf_counter()

# Scan for conditional files and sort them
raw_condition_files = []

for n in conditional_dirs:
    raw_condition_files += loaders.menudata_loader.find_menu_files(n)

conditional_files = loaders.menudata_loader.sort_menu_files(raw_condition_files)

# Load all conditional files, merging them in one
raw_conditionals = {}

for name in conditional_files:
    logging.info('Loading conditional file "%s"', name)

    try:
        with open(name, 'r', encoding='utf-8') as f:
            contents = f.read()

            if len(contents.strip()) == 0:
                # empty strings are invalid JSON, so manually "fix" empty files
                contents = '{}'

            data = json.loads(contents)
    except BaseException as e:
        logging.error("Can't load conditionals file \"%s\":", name)
        logging.error(e, exc_info=True)
        continue

    conds = filters.conditionals.load(data)

    if conds:
        raw_conditionals.update(conds)

# Evaluate the conditionals
conditionals = filters.conditionals.evaluate(raw_conditionals)

icon_cache = icon_cache.IconCache(1024, 48)

# Parse tags
tags = filters.tags.Filter(args.tags)

# Locate and load menudata files
raw_menu_files = []

for n in menudata_dirs:
    raw_menu_files += loaders.menudata_loader.find_menu_files(n)

menudata_files = loaders.menudata_loader.sort_menu_files(raw_menu_files)

# Load!
menudata = loaders.menudata_loader.load(
    menudata_files, args.lang,
    desktop_dirs, icon_dirs,
    tags, conditionals,
    {},     # no puavo-pkg states here
    icon_cache)

end_time = time.perf_counter()

utils.log_elapsed_time('Total load time', start_time, end_time)
