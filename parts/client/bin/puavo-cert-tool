#!/usr/bin/ruby

require 'fileutils'
require 'openssl'
require 'puavo/conf'
require 'puavo/rest-client'

mode              = ARGV[0]
certchain_version = ARGV[1]

def rest_client()
  PuavoRestClient.new(:auth => :etc, :dns => :no)
end

class CertificatePaths
  attr_reader :certdir

  def initialize(certchain_version, suffix='')
    @certdir = "/state/etc/puavo/certificates/#{ certchain_version }#{ suffix }"
  end

  def certificate    ; "#{ @certdir }/host.crt"           ; end
  def hostorgcabundle; "#{ @certdir }/hostorgcabundle.pem"; end
  def orgcabundle    ; "#{ @certdir }/orgcabundle.pem"    ; end
  def private_key    ; "#{ @certdir }/host.key"           ; end
  def rootca         ; "#{ @certdir }/rootca.pem"         ; end
end

class Certificates
  def initialize(certchain_version)
    @certchain_version = certchain_version
    @paths     = CertificatePaths.new(certchain_version)
    @tmp_paths = CertificatePaths.new(certchain_version, '.tmp')
  end

  def cert_ok?(textstr)
    textstr.kind_of?(String) && !textstr.empty?
  end

  def create()
    make_certificate_request
    sign_in_puavo
    write_to_filesystem
  end

  def update()
    raise 'unimplemented'

    # XXX what if certificate file is not found?
    # XXX should it automatically create a new one?

    cert = OpenSSL::X509::Certificate.new( File.read(certificate_file) )
    # do not update if certificate is valid for the next half a year
    return if (Time.now + 60 * 60 * 24 * 180) < cert.not_after

    key_pem = File.read('XXX certificate private key path')
    make_certificate_request(key_pem)
    sign_in_puavo
    write_to_filesystem
  end

  def make_certificate_request
    @key = OpenSSL::PKey::RSA.new(4096)
    csr = OpenSSL::X509::Request.new
    csr.version = 0
    csr.public_key = @key.public_key
    csr.sign(@key, OpenSSL::Digest::SHA512.new)

    @csr = csr
  end

  def sign_in_puavo
    begin
      msgobj = {
                 'certchain_version'   => @certchain_version,
                 'certificate_request' => @csr.to_pem,
               }
      response = rest_client().post('/v3/hosts/certs/sign',
                                    :json => msgobj)
    rescue PuavoRestClient::BadStatusCode => e
      begin
        error = JSON.parse(e.response.body)['error']['message']
      rescue StandardError => e
        raise "can not parse error message: #{ e.message }"
      end
      raise "error returned by server: #{ error }"
    end

    begin
      certificates = response.parse
    rescue StandardError => e
      raise "could not parse certificate signing response: #{ e.message }"
    end

    raise 'no host certificate in the server response' \
      unless cert_ok?(certificates['certificate'])
    raise 'no organisation ca certificate bundle in the server response' \
      unless cert_ok?(certificates['org_ca_certificate_bundle'])
    raise 'no root ca certificate in the server response' \
      unless cert_ok?(certificates['root_ca_certificate'])

    @host_cert     = certificates['certificate']
    @org_ca_bundle = certificates['org_ca_certificate_bundle']
    @root_ca       = certificates['root_ca_certificate']
  end

  def write_to_filesystem
    FileUtils.remove_entry_secure(@tmp_paths.certdir) \
      if File.exists?(@tmp_paths.certdir)

    FileUtils.mkdir_p(@tmp_paths.certdir)

    File.open(@tmp_paths.certificate, 'w', 0444) do |f|
      f.write(@host_cert)
    end
    File.open(@tmp_paths.private_key, 'w', 0400) do |f|
      f.print(@key.to_pem)
    end
    File.open(@tmp_paths.hostorgcabundle, 'w', 0444) do |f|
      f.print(@host_cert + @org_ca_bundle)
    end
    File.open(@tmp_paths.orgcabundle, 'w', 0444) do |f|
      f.print(@org_ca_bundle)
    end
    File.open(@tmp_paths.rootca, 'w', 0444) do |f|
      f.print(@root_ca)
    end

    old_certdir = "#{ @paths.certdir }.old"

    FileUtils.remove_entry_secure(old_certdir) \
      if File.exists?(old_certdir)

    # XXX How to update the real certificates file atomically?
    # XXX Or do we need to care (if not, then "update" should also
    # XXX be able to create certificates in case sometimes the first mv
    # XXX succeeds and the latter does not... otherwise the system will not
    # XXX be in a self-repairing state).

    FileUtils.mv(@paths.certdir, old_certdir) \
      if File.exists?(@paths.certdir)
    FileUtils.mv(@tmp_paths.certdir, @paths.certdir)

    FileUtils.remove_entry_secure(old_certdir) \
      if File.exists?(old_certdir)
  end
end

def usage
  puts <<EOF
Usage:
        #{ File.basename($0) } create [certchain_version]
        #{ File.basename($0) } update [certchain_version]
EOF

end

# XXX perhaps a --force option that creates certificates even if some
# XXX already exist...
# XXX and a --force option that updates certificates even if those are not
# XXX expiring soon...

case mode
  when 'create'
    action_method = :create
  when 'update'
    action_method = :update
  when nil
    usage
    exit 0
  else
    warn "unsupported mode: #{ mode }"
    usage
    exit 1
end

if certchain_version.nil? then
  puavoconf = Puavo::Conf.new
  certchain_version_list = puavoconf.get('puavo.admin.certs.versions').split
  puavoconf.close
else
  certchain_version_list = [ certchain_version ]
end

if certchain_version_list.empty? then
  warn 'no certificates to update in "puavo.admin.certs.versions"'
  exit 1
end

status = 0

certchain_version_list.each do |certchain_version|
  begin
    raise 'certificate chain version is not made of digits' \
      unless certchain_version.match(/\A\d+\z/)
    certificates = Certificates.new(certchain_version)
    certificates.send(action_method)
  rescue StandardError => e
    warn "error with certificate chain version #{ certchain_version }: " \
           + e.message
    status = 1
  end
end

exit(status)
